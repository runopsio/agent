shadow$provide.module$node_modules$$sentry$utils$dist$promisebuffer=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});var error_1=require("module$node_modules$$sentry$utils$dist$error"),syncpromise_1=require("module$node_modules$$sentry$utils$dist$syncpromise");global=function(){function PromiseBuffer(_limit){this._limit=_limit;this._buffer=[]}PromiseBuffer.prototype.isReady=function(){return void 0===this._limit||this.length()<this._limit};PromiseBuffer.prototype.add=
function(taskProducer){var _this=this;if(!this.isReady())return syncpromise_1.SyncPromise.reject(new error_1.SentryError("Not adding Promise due to buffer limit reached."));var task=taskProducer();-1===this._buffer.indexOf(task)&&this._buffer.push(task);void task.then(function(){return _this.remove(task)}).then(null,function(){return _this.remove(task).then(null,function(){})});return task};PromiseBuffer.prototype.remove=function(task){return this._buffer.splice(this._buffer.indexOf(task),1)[0]};
PromiseBuffer.prototype.length=function(){return this._buffer.length};PromiseBuffer.prototype.drain=function(timeout){var _this=this;return new syncpromise_1.SyncPromise(function(resolve){var capturedSetTimeout=setTimeout(function(){timeout&&0<timeout&&resolve(!1)},timeout);void syncpromise_1.SyncPromise.all(_this._buffer).then(function(){clearTimeout(capturedSetTimeout);resolve(!0)}).then(null,function(){resolve(!0)})})};return PromiseBuffer}();exports.PromiseBuffer=global}
//# sourceMappingURL=module$node_modules$$sentry$utils$dist$promisebuffer.js.map
