{
"version":3,
"file":"module$node_modules$$codemirror$stream_parser$dist$index_cjs.js",
"lineCount":22,
"mappings":"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",
"sources":["node_modules/@codemirror/stream-parser/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$codemirror$stream_parser$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar common = require('@lezer/common');\nvar highlight = require('@codemirror/highlight');\nvar language = require('@codemirror/language');\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1)\n            end = string.length;\n    }\n    let n = startValue;\n    for (let i = startIndex; i < end; i++) {\n        if (string.charCodeAt(i) == 9)\n            n += tabSize - (n % tabSize);\n        else\n            n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The line.\n    */\n    string, tabSize, \n    /**\n    The current indent unit size.\n    */\n    indentUnit) {\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        /**\n        The current position on the line.\n        */\n        this.pos = 0;\n        /**\n        The start position of the current token.\n        */\n        this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */\n    eol() { return this.pos >= this.string.length; }\n    /**\n    True if we are at the start of the line.\n    */\n    sol() { return this.pos == 0; }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */\n    peek() { return this.string.charAt(this.pos) || undefined; }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */\n    next() {\n        if (this.pos < this.string.length)\n            return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */\n    eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\")\n            ok = ch == match;\n        else\n            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */\n    eatWhile(match) {\n        let start = this.pos;\n        while (this.eat(match)) { }\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */\n    eatSpace() {\n        let start = this.pos;\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n            ++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */\n    skipToEnd() { this.pos = this.string.length; }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */\n    skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */\n    backUp(n) { this.pos -= n; }\n    /**\n    Get the column position at `this.pos`.\n    */\n    column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */\n    indentation() {\n        return countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */\n    match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false)\n                    this.pos += pattern.length;\n                return true;\n            }\n            else\n                return null;\n        }\n        else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0)\n                return null;\n            if (match && consume !== false)\n                this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */\n    current() { return this.string.slice(this.start, this.pos); }\n}\n\nfunction fullParser(spec) {\n    return {\n        token: spec.token,\n        blankLine: spec.blankLine || (() => { }),\n        startState: spec.startState || (() => true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (() => null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\")\n        return state;\n    let newState = {};\n    for (let prop in state) {\n        let val = state[prop];\n        newState[prop] = (val instanceof Array ? val.slice() : val);\n    }\n    return newState;\n}\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a streaming\nparser.\n*/\nclass StreamLanguage extends language.Language {\n    constructor(parser) {\n        let data = language.defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends common.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, docID(data), [language.indentService.of((cx, pos) => this.getIndent(cx, pos))]);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new common.NodeProp({ perNode: true });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    static define(spec) { return new StreamLanguage(spec); }\n    getIndent(cx, pos) {\n        let tree = language.syntaxTree(cx.state), at = tree.resolve(pos);\n        while (at && at.type != this.topNode)\n            at = at.parent;\n        if (!at)\n            return null;\n        let start = findState(this, tree, 0, at.from, pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        }\n        else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* MaxIndentScanDist */)\n            return null;\n        while (statePos < pos) {\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit);\n                while (stream.pos < end - line.from)\n                    readToken(this.streamParser.token, stream, state);\n            }\n            else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos)\n                break;\n            statePos = line.to + 1;\n        }\n        let { text } = cx.state.doc.lineAt(pos);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(text)[1], cx);\n    }\n    get allowsNesting() { return false; }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state)\n        return { state: lang.streamParser.copyState(state), pos: off + tree.length };\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof common.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found)\n            return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length)\n        return tree;\n    if (!inside && tree.type == lang.topNode)\n        inside = true;\n    for (let i = tree.children.length - 1; i >= 0; i--) {\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof common.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))\n                break;\n            return !inside ? inner\n                : new common.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments) {\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))\n            return { state: found.state, tree };\n    }\n    return { state: lang.streamParser.startState(editorState ? language.getIndentUnit(editorState) : 4), tree: common.Tree.empty };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges) {\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = language.ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for (let i = 0; i < tree.children.length; i++) {\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* MaxDistanceBeforeViewport */) {\n            this.state = this.lang.streamParser.startState(language.getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n    }\n    advance() {\n        let context = language.ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* ChunkSize */);\n        if (context)\n            end = Math.min(end, context.viewport.to);\n        while (this.parsedPos < end)\n            this.parseLine(context);\n        if (this.chunkStart < this.parsedPos)\n            this.finishChunk();\n        if (this.parsedPos >= parseEnd)\n            return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1)\n                chunk = chunk.slice(0, eol);\n        }\n        else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for (let index = this.rangeIndex;;) {\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end)\n                break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length)\n                break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return { line, end };\n    }\n    skipGapsTo(pos, offset, side) {\n        for (;;) {\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos)\n                break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? language.getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        }\n        else {\n            while (!stream.eol()) {\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token)\n                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* MaxLineLength */)\n                    break;\n            }\n        }\n        this.parsedPos = end;\n        if (this.parsedPos < this.to)\n            this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = common.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* ChunkSize */,\n            reused: this.chunkReused\n        });\n        tree = new common.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new common.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for (let i = 0; i < 10; i++) {\n        let result = token(stream, state);\n        if (stream.pos > stream.start)\n            return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = Object.create(null);\nconst typeArray = [common.NodeType.none];\nconst nodeSet = new common.NodeSet(typeArray);\nconst warned = [];\nconst defaultTable = Object.create(null);\nfor (let [legacyName, name] of [\n    [\"variable\", \"variableName\"],\n    [\"variable-2\", \"variableName.special\"],\n    [\"string-2\", \"string.special\"],\n    [\"def\", \"variableName.definition\"],\n    [\"tag\", \"typeName\"],\n    [\"attribute\", \"propertyName\"],\n    [\"type\", \"typeName\"],\n    [\"builtin\", \"variableName.standard\"],\n    [\"qualifier\", \"modifier\"],\n    [\"error\", \"invalid\"],\n    [\"header\", \"heading\"],\n    [\"property\", \"propertyName\"]\n])\n    defaultTable[legacyName] = createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra) {\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1)\n        return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tag = null;\n    for (let part of tagStr.split(\".\")) {\n        let value = (extra[part] || highlight.tags[part]);\n        if (!value) {\n            warnForPart(part, `Unknown highlighting tag ${part}`);\n        }\n        else if (typeof value == \"function\") {\n            if (!tag)\n                warnForPart(part, `Modifier ${part} used at start of tag`);\n            else\n                tag = value(tag);\n        }\n        else {\n            if (tag)\n                warnForPart(part, `Tag ${part} used as modifier`);\n            else\n                tag = value;\n        }\n    }\n    if (!tag)\n        return 0;\n    let name = tagStr.replace(/ /g, \"_\"), type = common.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [highlight.styleTags({ [name]: tag })]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = common.NodeType.define({ id: typeArray.length, name: \"Document\", props: [language.languageDataProp.add(() => data)] });\n    typeArray.push(type);\n    return type;\n}\n\nexports.StreamLanguage = StreamLanguage;\nexports.StringStream = StringStream;\n\n};"],
"names":["shadow$provide","global","require","module","exports","countCol","string","end","tabSize","startIndex","startValue","search","length","i","charCodeAt","n","fullParser","spec","token","blankLine","startState","copyState","defaultCopyState","indent","languageData","tokenTable","noTokens","state","newState","prop","val","Array","slice","findState","lang","tree","off","startPos","before","stateAfter","streamParser","pos","children","child","positions","found","common","Tree","cutTree","from","to","inside","type","topNode","inner","concat","readToken","stream","start","result","Error","warnForPart","part","msg","warned","indexOf","push","console","warn","createTokenType","extra","tagStr","tag","split","value","highlight","tags","name","replace","NodeType","define","id","typeArray","props","styleTags","docID","data","language","languageDataProp","add","Object","defineProperty","StringStream","constructor","indentUnit","lastColumnValue","lastColumnPos","eol","sol","peek","charAt","undefined","next","eat","match","ch","ok","RegExp","test","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","indentation","pattern","consume","caseInsensitive","substr","str","toLowerCase","index","current","StreamLanguage","Language","parser","defineLanguageFacet","p","self","impl","Parser","createParse","input","fragments","ranges","Parse","indentService","of","cx","getIndent","NodeProp","perNode","TokenTable","defaultTokenTable","syntaxTree","at","resolve","parent","statePos","unit","line","doc","lineAt","Math","min","text","exec","stoppedAt","chunks","chunkPos","chunk","chunkReused","rangeIndex","context","ParseContext","get","f","openEnd","openStart","offset","editorState","getIndentUnit","empty","parsedPos","chunkStart","viewport","skipUntilInView","advance","parseEnd","parseLine","finishChunk","finish","stopAt","lineAfter","lineChunks","nextLine","rangeEnd","rangeStart","after","skipGapsTo","side","offPos","emitToken","size","len0","build","buffer","nodeSet","topID","maxBufferLength","reused","balance","create","none","NodeSet","defaultTable","legacyName","table","assign"]
}
