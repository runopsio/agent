shadow$provide.module$node_modules$$codemirror$state$dist$index_cjs=function(global,require$jscomp$0,module,exports){function addSection(sections,len,ins,forceJoin=!1){if(!(0==len&&0>=ins)){var last=sections.length-2;0<=last&&0>=ins&&ins==sections[last+1]?sections[last]+=len:0==len&&0==sections[last]?sections[last+1]+=ins:forceJoin?(sections[last]+=len,sections[last+1]+=ins):sections.push(len,ins)}}function addInsert(values,sections,value){if(0!=value.length)if(sections=sections.length-2>>1,sections<
values.length)values[values.length-1]=values[values.length-1].append(value);else{for(;values.length<sections;)values.push(text$jscomp$0.Text.empty);values.push(value)}}function iterChanges(desc,f,individual){let inserted=desc.inserted;for(let posA=0,posB=0,i=0;i<desc.sections.length;){let len=desc.sections[i++],ins=desc.sections[i++];if(0>ins)posA+=len,posB+=len;else{let endA=posA,endB=posB,text$1=text$jscomp$0.Text.empty;for(;;){endA+=len;endB+=ins;ins&&inserted&&(text$1=text$1.append(inserted[i-
2>>1]));if(individual||i==desc.sections.length||0>desc.sections[i+1])break;len=desc.sections[i++];ins=desc.sections[i++]}f(posA,endA,posB,endB,text$1);posA=endA;posB=endB}}}function mapSet(setA,setB,before,mkSet=!1){let sections=[];mkSet=mkSet?[]:null;setA=new SectionIter(setA);setB=new SectionIter(setB);for(let posA=0,posB=0;;)if(-1==setA.ins)posA+=setA.len,setA.next();else if(-1==setB.ins&&posB<posA){var skip$jscomp$0=Math.min(setB.len,posA-posB);setB.forward(skip$jscomp$0);addSection(sections,
skip$jscomp$0,-1);posB+=skip$jscomp$0}else if(0<=setB.ins&&(setA.done||posB<posA||posB==posA&&(setB.len<setA.len||setB.len==setA.len&&!before))){for(addSection(sections,setB.ins,-1);posA>posB&&!setA.done&&posA+setA.len<posB+setB.len;)posA+=setA.len,setA.next();posB+=setB.len;setB.next()}else if(0<=setA.ins){skip$jscomp$0=0;let end=posA+setA.len;for(;;)if(0<=setB.ins&&posB>posA&&posB+setB.len<end)skip$jscomp$0+=setB.ins,posB+=setB.len,setB.next();else if(-1==setB.ins&&posB<end){let skip=Math.min(setB.len,
end-posB);skip$jscomp$0+=skip;setB.forward(skip);posB+=skip}else break;addSection(sections,skip$jscomp$0,setA.ins);mkSet&&addInsert(mkSet,sections,setA.text);posA=end;setA.next()}else{if(setA.done&&setB.done)return mkSet?new ChangeSet(sections,mkSet):new ChangeDesc(sections);throw Error("Mismatched change set lengths");}}function composeSets(setA,setB,mkSet=!1){let sections=[];mkSet=mkSet?[]:null;setA=new SectionIter(setA);setB=new SectionIter(setB);for(let open=!1;;){if(setA.done&&setB.done)return mkSet?
new ChangeSet(sections,mkSet):new ChangeDesc(sections);if(0==setA.ins)addSection(sections,setA.len,0,open),setA.next();else if(0!=setB.len||setB.done){if(setA.done||setB.done)throw Error("Mismatched change set lengths");let len=Math.min(setA.len2,setB.len),sectionLen=sections.length;if(-1==setA.ins){let insB=-1==setB.ins?-1:setB.off?0:setB.ins;addSection(sections,len,insB,open);mkSet&&insB&&addInsert(mkSet,sections,setB.text)}else-1==setB.ins?(addSection(sections,setA.off?0:setA.len,len,open),mkSet&&
addInsert(mkSet,sections,setA.textBit(len))):(addSection(sections,setA.off?0:setA.len,setB.off?0:setB.ins,open),mkSet&&!setB.off&&addInsert(mkSet,sections,setB.text));open=(setA.ins>len||0<=setB.ins&&setB.len>len)&&(open||sections.length>sectionLen);setA.forward2(len);setB.forward(len)}else addSection(sections,0,setB.ins,open),mkSet&&addInsert(mkSet,sections,setB.text),setB.next()}}function normalized(ranges,mainIndex=0){mainIndex=ranges[mainIndex];ranges.sort((a,b)=>a.from-b.from);mainIndex=ranges.indexOf(mainIndex);
for(let i=1;i<ranges.length;i++){let range=ranges[i];var prev=ranges[i-1];if(range.empty?range.from<=prev.to:range.from<prev.to){let from=prev.from;prev=Math.max(range.to,prev.to);i<=mainIndex&&mainIndex--;ranges.splice(--i,2,range.anchor>range.head?EditorSelection.range(prev,from):EditorSelection.range(from,prev))}}return new EditorSelection(ranges,mainIndex)}function checkSelection(selection,docLength){for(let range of selection.ranges)if(range.to>docLength)throw new RangeError("Selection points outside of document");
}function sameArray(a,b){return a==b||a.length==b.length&&a.every((e,i)=>e===b[i])}function compareArray(a,b,compare){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compare(a[i],b[i]))return!1;return!0}function dynamicFacetSlot(addresses,facet,providers){let providerAddrs=providers.map(p=>addresses[p.id]),providerTypes=providers.map(p=>p.type),dynamic=providerAddrs.filter(p=>!(p&1)),idx=addresses[facet.id]>>1;return(state,tr)=>{tr=state.values[idx];var changed=tr===Uninitialized;for(var dynAddr of dynamic)ensureAddr(state,
dynAddr)&1&&(changed=!0);if(!changed)return 0;dynAddr=[];for(changed=0;changed<providerAddrs.length;changed++){let value=getAddr(state,providerAddrs[changed]);if(2==providerTypes[changed])for(var val of value)dynAddr.push(val);else dynAddr.push(value)}val=facet.combine(dynAddr);if(tr!==Uninitialized&&facet.compare(val,tr))return 0;state.values[idx]=val;return 1}}function prec(value){return ext=>new PrecExtension(ext,value)}function flatten(extension,compartments,newCompartments){function inner(ext,
prec){var known=seen.get(ext);if(null!=known){if(known>=prec)return;let found=result[known].indexOf(ext);-1<found&&result[known].splice(found,1);ext instanceof CompartmentInstance&&newCompartments.delete(ext.compartment)}seen.set(ext,prec);if(Array.isArray(ext))for(let e of ext)inner(e,prec);else if(ext instanceof CompartmentInstance){if(newCompartments.has(ext.compartment))throw new RangeError("Duplicate use of compartment in extensions");known=compartments.get(ext.compartment)||ext.inner;newCompartments.set(ext.compartment,
known);inner(known,prec)}else if(ext instanceof PrecExtension)inner(ext.inner,ext.prec);else if(ext instanceof StateField)result[prec].push(ext),ext.provides&&inner(ext.provides,prec);else if(ext instanceof FacetProvider)result[prec].push(ext),ext.facet.extensions&&inner(ext.facet.extensions,prec);else{known=ext.extension;if(!known)throw Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
inner(known,prec)}}let result=[[],[],[],[],[]],seen=new Map;inner(extension,Prec_.default);return result.reduce((a,b)=>a.concat(b))}function ensureAddr(state,addr){if(addr&1)return 2;addr>>=1;var status=state.status[addr];if(4==status)throw Error("Cyclic dependency between fields and/or facets");if(status&2)return status;state.status[addr]=4;status=state.config.dynamicSlots[addr](state,state.applying);return state.status[addr]=2|status}function getAddr(state,addr){return addr&1?state.config.staticValues[addr>>
1]:state.values[addr>>1]}function mergeTransaction(a,b,sequential){var _a;let mapForB,changes;sequential?(sequential=b.changes,mapForB=ChangeSet.empty(b.changes.length),changes=a.changes.compose(b.changes)):(sequential=b.changes.map(a.changes),mapForB=a.changes.mapDesc(b.changes,!0),changes=a.changes.compose(sequential));return{changes,selection:b.selection?b.selection.map(mapForB):null===(_a=a.selection)||void 0===_a?void 0:_a.map(sequential),effects:StateEffect.mapEffects(a.effects,sequential).concat(StateEffect.mapEffects(b.effects,
mapForB)),annotations:a.annotations.length?a.annotations.concat(b.annotations):b.annotations,scrollIntoView:a.scrollIntoView||b.scrollIntoView}}function resolveTransactionInner(state,spec,docSize){let sel=spec.selection,annotations=asArray(spec.annotations);spec.userEvent&&(annotations=annotations.concat(Transaction.userEvent.of(spec.userEvent)));return{changes:spec.changes instanceof ChangeSet?spec.changes:ChangeSet.of(spec.changes||[],docSize,state.facet(lineSeparator)),selection:sel&&(sel instanceof
EditorSelection?sel:EditorSelection.single(sel.anchor,sel.head)),effects:asArray(spec.effects),annotations,scrollIntoView:!!spec.scrollIntoView}}function resolveTransaction(state,specs,filter){var s=resolveTransactionInner(state,specs.length?specs[0]:{},state.doc.length);specs.length&&!1===specs[0].filter&&(filter=!1);for(var i=1;i<specs.length;i++){!1===specs[i].filter&&(filter=!1);var seq=!!specs[i].sequential;s=mergeTransaction(s,resolveTransactionInner(state,specs[i],seq?s.changes.newLength:state.doc.length),
seq)}state=new Transaction(state,s.changes,s.selection,s.effects,s.annotations,s.scrollIntoView);if(filter){filter=state.startState;specs=!0;for(JSCompiler_temp of filter.facet(changeFilter)){s=JSCompiler_temp(state);if(!1===s){specs=!1;break}if(Array.isArray(s))if(!0===specs)specs=s;else a:{i=[];for(let iA=0,iB=0;;){let to;if(iA<specs.length&&(iB==s.length||s[iB]>=specs[iA]))seq=specs[iA++],to=specs[iA++];else if(iB<s.length)seq=s[iB++],to=s[iB++];else{specs=i;break a}!i.length||i[i.length-1]<seq?
i.push(seq,to):i[i.length-1]<to&&(i[i.length-1]=to)}}}if(!0!==specs){if(!1===specs){specs=state.changes.invertedDesc;var JSCompiler_temp=ChangeSet.empty(filter.doc.length)}else specs=state.changes.filter(specs),JSCompiler_temp=specs.changes,specs=specs.filtered.invertedDesc;state=new Transaction(filter,JSCompiler_temp,state.selection&&state.selection.map(specs),StateEffect.mapEffects(state.effects,specs),state.annotations,state.scrollIntoView)}JSCompiler_temp=filter.facet(transactionFilter);for(specs=
JSCompiler_temp.length-1;0<=specs;specs--)state=JSCompiler_temp[specs](state),state=state instanceof Transaction?state:Array.isArray(state)&&1==state.length&&state[0]instanceof Transaction?state[0]:resolveTransaction(filter,asArray(state),!1);JSCompiler_temp=state}else JSCompiler_temp=state;filter=JSCompiler_temp.startState;state=filter.facet(transactionExtender);specs=JSCompiler_temp;for(s=state.length-1;0<=s;s--)(i=state[s](JSCompiler_temp))&&Object.keys(i).length&&(specs=mergeTransaction(JSCompiler_temp,
resolveTransactionInner(filter,i,JSCompiler_temp.changes.newLength),!0));return specs==JSCompiler_temp?JSCompiler_temp:new Transaction(filter,JSCompiler_temp.changes,JSCompiler_temp.selection,specs.effects,specs.annotations,specs.scrollIntoView)}function asArray(value){return null==value?none:Array.isArray(value)?value:[value]}function makeCategorizer(wordChars){return char=>{if(!/\S/.test(char))return exports.CharCategory.Space;a:if(wordChar)var JSCompiler_inline_result=wordChar.test(char);else{for(JSCompiler_inline_result=
0;JSCompiler_inline_result<char.length;JSCompiler_inline_result++){let ch=char[JSCompiler_inline_result];if(/\w/.test(ch)||"Â€"<ch&&(ch.toUpperCase()!=ch.toLowerCase()||nonASCIISingleCaseWordChar.test(ch))){JSCompiler_inline_result=!0;break a}}JSCompiler_inline_result=!1}if(JSCompiler_inline_result)return exports.CharCategory.Word;for(JSCompiler_inline_result=0;JSCompiler_inline_result<wordChars.length;JSCompiler_inline_result++)if(-1<char.indexOf(wordChars[JSCompiler_inline_result]))return exports.CharCategory.Word;
return exports.CharCategory.Other}}Object.defineProperty(exports,"__esModule",{value:!0});var text$jscomp$0=require$jscomp$0("module$node_modules$$codemirror$text$dist$index_cjs");const DefaultSplit=/\r\n?|\n/;exports.MapMode=void 0;(function(MapMode){MapMode[MapMode.Simple=0]="Simple";MapMode[MapMode.TrackDel=1]="TrackDel";MapMode[MapMode.TrackBefore=2]="TrackBefore";MapMode[MapMode.TrackAfter=3]="TrackAfter"})(exports.MapMode||(exports.MapMode={}));class ChangeDesc{constructor(sections){this.sections=
sections}get length(){let result=0;for(let i=0;i<this.sections.length;i+=2)result+=this.sections[i];return result}get newLength(){let result=0;for(let i=0;i<this.sections.length;i+=2){let ins=this.sections[i+1];result+=0>ins?this.sections[i]:ins}return result}get empty(){return 0==this.sections.length||2==this.sections.length&&0>this.sections[1]}iterGaps(f){for(let i=0,posA=0,posB=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];0>ins?(f(posA,posB,len),posB+=len):posB+=
ins;posA+=len}}iterChangedRanges(f,individual=!1){iterChanges(this,f,individual)}get invertedDesc(){let sections=[];for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];0>ins?sections.push(len,ins):sections.push(ins,len)}return new ChangeDesc(sections)}composeDesc(other){return this.empty?other:other.empty?this:composeSets(this,other)}mapDesc(other,before=!1){return other.empty?this:mapSet(this,other,before)}mapPos(pos,assoc=-1,mode=exports.MapMode.Simple){let posA=
0,posB=0;for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++],endA=posA+len;if(0>ins){if(endA>pos)return posB+(pos-posA);posB+=len}else{if(mode!=exports.MapMode.Simple&&endA>=pos&&(mode==exports.MapMode.TrackDel&&posA<pos&&endA>pos||mode==exports.MapMode.TrackBefore&&posA<pos||mode==exports.MapMode.TrackAfter&&endA>pos))return null;if(endA>pos||endA==pos&&0>assoc&&!len)return pos==posA||0>assoc?posB:posB+ins;posB+=ins}posA=endA}if(pos>posA)throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
return posB}touchesRange(from,to=from){for(let i=0,pos=0;i<this.sections.length&&pos<=to;){var len=this.sections[i++];let ins=this.sections[i++];len=pos+len;if(0<=ins&&pos<=to&&len>=from)return pos<from&&len>to?"cover":!0;pos=len}return!1}toString(){let result="";for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];result+=(result?" ":"")+len+(0<=ins?":"+ins:"")}return result}toJSON(){return this.sections}static fromJSON(json){if(!Array.isArray(json)||json.length%
2||json.some(a=>"number"!=typeof a))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(json)}}class ChangeSet extends ChangeDesc{constructor(sections,inserted){super(sections);this.inserted=inserted}apply(doc){if(this.length!=doc.length)throw new RangeError("Applying change set to a document with the wrong length");iterChanges(this,(fromA,toA,fromB,_toB,text)=>doc=doc.replace(fromB,fromB+(toA-fromA),text),!1);return doc}mapDesc(other,before=!1){return mapSet(this,
other,before,!0)}invert(doc){let sections=this.sections.slice(),inserted=[];for(let i=0,pos=0;i<sections.length;i+=2){let len=sections[i];var ins=sections[i+1];if(0<=ins){sections[i]=ins;sections[i+1]=len;for(ins=i>>1;inserted.length<ins;)inserted.push(text$jscomp$0.Text.empty);inserted.push(len?doc.slice(pos,pos+len):text$jscomp$0.Text.empty)}pos+=len}return new ChangeSet(sections,inserted)}compose(other){return this.empty?other:other.empty?this:composeSets(this,other,!0)}map(other,before=!1){return other.empty?
this:mapSet(this,other,before,!0)}iterChanges(f,individual=!1){iterChanges(this,f,individual)}get desc(){return new ChangeDesc(this.sections)}filter(ranges){let resultSections=[],resultInserted=[],filteredSections=[],iter=new SectionIter(this);a:for(let i=0,pos=0;;){for(var next=i==ranges.length?1E9:ranges[i++];pos<next||pos==next&&0==iter.len;){if(iter.done)break a;var len=Math.min(iter.len,next-pos);addSection(filteredSections,len,-1);let ins=-1==iter.ins?-1:0==iter.off?iter.ins:0;addSection(resultSections,
len,ins);0<ins&&addInsert(resultInserted,resultSections,iter.text);iter.forward(len);pos+=len}for(next=ranges[i++];pos<next;){if(iter.done)break a;len=Math.min(iter.len,next-pos);addSection(resultSections,len,-1);addSection(filteredSections,len,-1==iter.ins?-1:0==iter.off?iter.ins:0);iter.forward(len);pos+=len}}return{changes:new ChangeSet(resultSections,resultInserted),filtered:new ChangeDesc(filteredSections)}}toJSON(){let parts=[];for(let i=0;i<this.sections.length;i+=2){let len=this.sections[i],
ins=this.sections[i+1];0>ins?parts.push(len):0==ins?parts.push([len]):parts.push([len].concat(this.inserted[i>>1].toJSON()))}return parts}static of(changes,length,lineSep){function flush(force=!1){if(force||sections.length)pos<length&&addSection(sections,length-pos,-1),force=new ChangeSet(sections,inserted),total=total?total.compose(force.map(total)):force,sections=[],inserted=[],pos=0}function process(spec){if(Array.isArray(spec))for(var sub of spec)process(sub);else if(spec instanceof ChangeSet){if(spec.length!=
length)throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);flush();total=total?total.compose(spec.map(total)):spec}else{let {from,to=from,insert}=spec;if(from>to||0>from||to>length)throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);spec=insert?"string"==typeof insert?text$jscomp$0.Text.of(insert.split(lineSep||DefaultSplit)):insert:text$jscomp$0.Text.empty;sub=spec.length;if(from!=to||0!=sub)from<pos&&flush(),from>pos&&
addSection(sections,from-pos,-1),addSection(sections,to-from,sub),addInsert(inserted,sections,spec),pos=to}}let sections=[],inserted=[],pos=0,total=null;process(changes);flush(!total);return total}static empty(length){return new ChangeSet(length?[length,-1]:[],[])}static fromJSON(json){if(!Array.isArray(json))throw new RangeError("Invalid JSON representation of ChangeSet");let sections=[],inserted=[];for(let i$jscomp$0=0;i$jscomp$0<json.length;i$jscomp$0++){let part=json[i$jscomp$0];if("number"==
typeof part)sections.push(part,-1);else{if(!Array.isArray(part)||"number"!=typeof part[0]||part.some((e,i)=>i&&"string"!=typeof e))throw new RangeError("Invalid JSON representation of ChangeSet");if(1==part.length)sections.push(part[0],0);else{for(;inserted.length<i$jscomp$0;)inserted.push(text$jscomp$0.Text.empty);inserted[i$jscomp$0]=text$jscomp$0.Text.of(part.slice(1));sections.push(part[0],inserted[i$jscomp$0].length)}}}return new ChangeSet(sections,inserted)}}class SectionIter{constructor(set){this.set=
set;this.i=0;this.next()}next(){let {sections}=this.set;this.i<sections.length?(this.len=sections[this.i++],this.ins=sections[this.i++]):(this.len=0,this.ins=-2);this.off=0}get done(){return-2==this.ins}get len2(){return 0>this.ins?this.len:this.ins}get text(){let {inserted}=this.set,index=this.i-2>>1;return index>=inserted.length?text$jscomp$0.Text.empty:inserted[index]}textBit(len){let {inserted}=this.set,index=this.i-2>>1;return index>=inserted.length&&!len?text$jscomp$0.Text.empty:inserted[index].slice(this.off,
null==len?void 0:this.off+len)}forward(len){len==this.len?this.next():(this.len-=len,this.off+=len)}forward2(len){-1==this.ins?this.forward(len):len==this.ins?this.next():(this.ins-=len,this.off+=len)}}class SelectionRange{constructor(from,to,flags){this.from=from;this.to=to;this.flags=flags}get anchor(){return this.flags&16?this.to:this.from}get head(){return this.flags&16?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return this.flags&4?-1:this.flags&8?1:0}get bidiLevel(){let level=
this.flags&3;return 3==level?null:level}get goalColumn(){let value=this.flags>>5;return 33554431==value?void 0:value}map(change,assoc=-1){let from=change.mapPos(this.from,assoc);change=change.mapPos(this.to,assoc);return from==this.from&&change==this.to?this:new SelectionRange(from,change,this.flags)}extend(from,to=from){return from<=this.anchor&&to>=this.anchor?EditorSelection.range(from,to):EditorSelection.range(this.anchor,Math.abs(from-this.anchor)>Math.abs(to-this.anchor)?from:to)}eq(other){return this.anchor==
other.anchor&&this.head==other.head}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(json){if(!json||"number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(json.anchor,json.head)}}class EditorSelection{constructor(ranges,mainIndex=0){this.ranges=ranges;this.mainIndex=mainIndex}map(change,assoc=-1){return change.empty?this:EditorSelection.create(this.ranges.map(r=>r.map(change,assoc)),
this.mainIndex)}eq(other){if(this.ranges.length!=other.ranges.length||this.mainIndex!=other.mainIndex)return!1;for(let i=0;i<this.ranges.length;i++)if(!this.ranges[i].eq(other.ranges[i]))return!1;return!0}get main(){return this.ranges[this.mainIndex]}asSingle(){return 1==this.ranges.length?this:new EditorSelection([this.main])}addRange(range,main=!0){return EditorSelection.create([range].concat(this.ranges),main?0:this.mainIndex+1)}replaceRange(range,which=this.mainIndex){let ranges=this.ranges.slice();
ranges[which]=range;return EditorSelection.create(ranges,this.mainIndex)}toJSON(){return{ranges:this.ranges.map(r=>r.toJSON()),main:this.mainIndex}}static fromJSON(json){if(!json||!Array.isArray(json.ranges)||"number"!=typeof json.main||json.main>=json.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(json.ranges.map(r=>SelectionRange.fromJSON(r)),json.main)}static single(anchor,head=anchor){return new EditorSelection([EditorSelection.range(anchor,
head)],0)}static create(ranges,mainIndex=0){if(0==ranges.length)throw new RangeError("A selection needs at least one range");for(let pos=0,i=0;i<ranges.length;i++){let range=ranges[i];if(range.empty?range.from<=pos:range.from<pos)return normalized(ranges.slice(),mainIndex);pos=range.to}return new EditorSelection(ranges,mainIndex)}static cursor(pos,assoc=0,bidiLevel,goalColumn){return new SelectionRange(pos,pos,(0==assoc?0:0>assoc?4:8)|(null==bidiLevel?3:Math.min(2,bidiLevel))|(null!==goalColumn&&
void 0!==goalColumn?goalColumn:33554431)<<5)}static range(anchor,head,goalColumn){goalColumn=(null!==goalColumn&&void 0!==goalColumn?goalColumn:33554431)<<5;return head<anchor?new SelectionRange(head,anchor,goalColumn|24):new SelectionRange(anchor,head,goalColumn|(head>anchor?4:0))}}let nextID=0;class Facet{constructor(combine,compareInput,compare,isStatic,extensions){this.combine=combine;this.compareInput=compareInput;this.compare=compare;this.isStatic=isStatic;this.extensions=extensions;this.id=
nextID++;this.default=combine([])}static define(config={}){return new Facet(config.combine||(a=>a),config.compareInput||((a,b)=>a===b),config.compare||(config.combine?(a,b)=>a===b:sameArray),!!config.static,config.enables)}of(value){return new FacetProvider([],this,0,value)}compute(deps,get){if(this.isStatic)throw Error("Can't compute a static facet");return new FacetProvider(deps,this,1,get)}computeN(deps,get){if(this.isStatic)throw Error("Can't compute a static facet");return new FacetProvider(deps,
this,2,get)}from(field,get){get||(get=x=>x);return this.compute([field],state=>get(state.field(field)))}}class FacetProvider{constructor(dependencies,facet,type,value){this.dependencies=dependencies;this.facet=facet;this.type=type;this.value=value;this.id=nextID++}dynamicSlot(addresses){var _a;let getter=this.value,compare=this.facet.compareInput,idx=addresses[this.id]>>1,multi=2==this.type,depDoc=!1,depSel=!1,depAddrs=[];for(let dep of this.dependencies)"doc"==dep?depDoc=!0:"selection"==dep?depSel=
!0:0==((null!==(_a=addresses[dep.id])&&void 0!==_a?_a:1)&1)&&depAddrs.push(addresses[dep.id]);return(state,tr)=>{let oldVal=state.values[idx];return oldVal===Uninitialized?(state.values[idx]=getter(state),1):tr&&(depDoc&&tr.docChanged||depSel&&(tr.docChanged||tr.selection)||depAddrs.some(addr=>0<(ensureAddr(state,addr)&1)))&&(tr=getter(state),multi?!compareArray(tr,oldVal,compare):!compare(tr,oldVal))?(state.values[idx]=tr,1):0}}}const initField=Facet.define({static:!0});class StateField{constructor(id,
createF,updateF,compareF,spec){this.id=id;this.createF=createF;this.updateF=updateF;this.compareF=compareF;this.spec=spec;this.provides=void 0}static define(config){let field=new StateField(nextID++,config.create,config.update,config.compare||((a,b)=>a===b),config);config.provide&&(field.provides=config.provide(field));return field}create(state){let init=state.facet(initField).find(i=>i.field==this);return((null===init||void 0===init?void 0:init.create)||this.createF)(state)}slot(addresses){let idx=
addresses[this.id]>>1;return(state,tr)=>{let oldVal=state.values[idx];return oldVal===Uninitialized?(state.values[idx]=this.create(state),1):tr&&(tr=this.updateF(oldVal,tr),!this.compareF(oldVal,tr))?(state.values[idx]=tr,1):0}}init(create){return[this,initField.of({field:this,create})]}get extension(){return this}}const Prec_={lowest:4,low:3,default:2,high:1,highest:0};global={lowest:prec(Prec_.lowest),low:prec(Prec_.low),default:prec(Prec_.default),high:prec(Prec_.high),highest:prec(Prec_.highest),
fallback:prec(Prec_.lowest),extend:prec(Prec_.high),override:prec(Prec_.highest)};class PrecExtension{constructor(inner,prec){this.inner=inner;this.prec=prec}}class Compartment{of(ext){return new CompartmentInstance(this,ext)}reconfigure(content){return Compartment.reconfigure.of({compartment:this,extension:content})}get(state){return state.config.compartments.get(this)}}class CompartmentInstance{constructor(compartment,inner){this.compartment=compartment;this.inner=inner}}class Configuration{constructor(base,
compartments,dynamicSlots,address,staticValues,facets){this.base=base;this.compartments=compartments;this.dynamicSlots=dynamicSlots;this.address=address;this.staticValues=staticValues;this.facets=facets;for(this.statusTemplate=[];this.statusTemplate.length<dynamicSlots.length;)this.statusTemplate.push(0)}staticFacet(facet){let addr=this.address[facet.id];return null==addr?facet.default:this.staticValues[addr>>1]}static resolve(base,compartments,oldState){var fields=[];let facets=Object.create(null),
newCompartments=new Map;for(var ext of flatten(base,compartments,newCompartments))ext instanceof StateField?fields.push(ext):(facets[ext.facet.id]||(facets[ext.facet.id]=[])).push(ext);let address=Object.create(null);compartments=[];let dynamicSlots=[];ext=[];for(let field of fields)address[field.id]=dynamicSlots.length<<1,dynamicSlots.push(a=>field.slot(a)),ext.push(oldState&&null!=oldState.config.address[field.id]?oldState.field(field):Uninitialized);let canReuseCache=new Map,canReuseDep=dep=>{if(!(dep instanceof
Facet))return!0;let cached=canReuseCache.get(dep);if(null!=cached)return cached;canReuseCache.set(dep,!1);if(oldFacets&&sameArray(oldFacets[dep.id]||[],facets[dep.id]||[])){for(let input of facets[dep.id]||[])if(!input.dependencies.every(canReuseDep))return;canReuseCache.set(dep,!0)}},oldFacets=null===oldState||void 0===oldState?void 0:oldState.config.facets;for(let id in facets){let providers=facets[id],facet=providers[0].facet;var oldProviders=oldFacets&&oldFacets[id]||[];fields=sameArray(providers,
oldProviders);if(providers.every(p=>0==p.type)){address[facet.id]=compartments.length<<1|1;oldProviders=fields?oldState.facet(facet):facet.combine(providers.map(p=>p.value));let oldValue;!fields&&oldState&&facet.compare(oldProviders,oldValue=oldState.facet(facet))&&(oldProviders=oldValue);compartments.push(oldProviders)}else{for(let p of providers){var canReuseThis=p.dependencies.every(canReuseDep);canReuseThis||(fields=!1);0==p.type?(address[p.id]=compartments.length<<1|1,compartments.push(p.value)):
(address[p.id]=dynamicSlots.length<<1,dynamicSlots.push(a=>p.dynamicSlot(a)),canReuseThis=oldState&&canReuseThis?oldState.config.address[p.id]:null,ext.push(null!=canReuseThis?getAddr(oldState,canReuseThis):Uninitialized))}address[facet.id]=dynamicSlots.length<<1;dynamicSlots.push(a=>dynamicFacetSlot(a,facet,providers));ext.push(fields||oldProviders.length?oldState.facet(facet):Uninitialized)}}oldState=dynamicSlots.map(f=>f(address));return{configuration:new Configuration(base,newCompartments,oldState,
address,compartments,facets),values:ext}}}const Uninitialized={},languageData=Facet.define(),allowMultipleSelections=Facet.define({combine:values=>values.some(v=>v),static:!0}),lineSeparator=Facet.define({combine:values=>values.length?values[0]:void 0,static:!0}),changeFilter=Facet.define(),transactionFilter=Facet.define(),transactionExtender=Facet.define(),readOnly=Facet.define({combine:values=>values.length?values[0]:!1});class Annotation{constructor(type,value){this.type=type;this.value=value}static define(){return new AnnotationType}}
class AnnotationType{of(value){return new Annotation(this,value)}}class StateEffectType{constructor(map){this.map=map}of(value){return new StateEffect(this,value)}}class StateEffect{constructor(type,value){this.type=type;this.value=value}map(mapping){mapping=this.type.map(this.value,mapping);return void 0===mapping?void 0:mapping==this.value?this:new StateEffect(this.type,mapping)}is(type){return this.type==type}static define(spec={}){return new StateEffectType(spec.map||(v=>v))}static mapEffects(effects,
mapping){if(!effects.length)return effects;let result=[];for(let effect of effects)(effects=effect.map(mapping))&&result.push(effects);return result}}StateEffect.reconfigure=StateEffect.define();StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(startState,changes,selection,effects,annotations,scrollIntoView){this.startState=startState;this.changes=changes;this.selection=selection;this.effects=effects;this.annotations=annotations;this.scrollIntoView=scrollIntoView;this._state=
this._doc=null;selection&&checkSelection(selection,changes.newLength);annotations.some(a=>a.type==Transaction.time)||(this.annotations=annotations.concat(Transaction.time.of(Date.now())))}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){this._state||this.startState.applyTransaction(this);return this._state}annotation(type){for(let ann of this.annotations)if(ann.type==
type)return ann.value}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(event){let e=this.annotation(Transaction.userEvent);return!(!e||!(e==event||e.length>event.length&&e.slice(0,event.length)==event&&"."==e[event.length]))}}Transaction.time=Annotation.define();Transaction.userEvent=Annotation.define();Transaction.addToHistory=Annotation.define();Transaction.remote=Annotation.define();const none=[];exports.CharCategory=void 0;
(function(CharCategory){CharCategory[CharCategory.Word=0]="Word";CharCategory[CharCategory.Space=1]="Space";CharCategory[CharCategory.Other=2]="Other"})(exports.CharCategory||(exports.CharCategory={}));const nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let wordChar;try{wordChar=RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(_){}class EditorState{constructor(config,doc,selection,values,tr=null){this.config=
config;this.doc=doc;this.selection=selection;this.values=values;this.applying=null;this.status=config.statusTemplate.slice();if(this.applying=tr)tr._state=this;for(config=0;config<this.config.dynamicSlots.length;config++)ensureAddr(this,config<<1);this.applying=null}field(field,require=!0){field=this.config.address[field.id];if(null==field){if(require)throw new RangeError("Field is not present in this state");}else return ensureAddr(this,field),getAddr(this,field)}update(...specs){return resolveTransaction(this,
specs,!0)}applyTransaction(tr){let conf=this.config,{base,compartments}=conf;for(var effect of tr.effects)effect.is(Compartment.reconfigure)?(conf&&(compartments=new Map,conf.compartments.forEach((val,key)=>compartments.set(key,val)),conf=null),compartments.set(effect.value.compartment,effect.value.extension)):effect.is(StateEffect.reconfigure)?(conf=null,base=effect.value):effect.is(StateEffect.appendConfig)&&(conf=null,base=asArray(base).concat(effect.value));conf?effect=tr.startState.values.slice():
(effect=Configuration.resolve(base,compartments,this),conf=effect.configuration,effect=(new EditorState(conf,this.doc,this.selection,effect.values,null)).values);new EditorState(conf,tr.newDoc,tr.newSelection,effect,tr)}replaceSelection(text){"string"==typeof text&&(text=this.toText(text));return this.changeByRange(range=>({changes:{from:range.from,to:range.to,insert:text},range:EditorSelection.cursor(range.from+text.length)}))}changeByRange(f){let sel=this.selection;var result1=f(sel.ranges[0]);
let changes=this.changes(result1.changes),ranges=[result1.range];result1=asArray(result1.effects);for(let i=1;i<sel.ranges.length;i++){let result=f(sel.ranges[i]);var newChanges=this.changes(result.changes);let newMapped=newChanges.map(changes);for(let j=0;j<i;j++)ranges[j]=ranges[j].map(newMapped);newChanges=changes.mapDesc(newChanges,!0);ranges.push(result.range.map(newChanges));changes=changes.compose(newMapped);result1=StateEffect.mapEffects(result1,newMapped).concat(StateEffect.mapEffects(asArray(result.effects),
newChanges))}return{changes,selection:EditorSelection.create(ranges,sel.mainIndex),effects:result1}}changes(spec=[]){return spec instanceof ChangeSet?spec:ChangeSet.of(spec,this.doc.length,this.facet(EditorState.lineSeparator))}toText(string){return text$jscomp$0.Text.of(string.split(this.facet(EditorState.lineSeparator)||DefaultSplit))}sliceDoc(from=0,to=this.doc.length){return this.doc.sliceString(from,to,this.lineBreak)}facet(facet){let addr=this.config.address[facet.id];if(null==addr)return facet.default;
ensureAddr(this,addr);return getAddr(this,addr)}toJSON(fields){let result={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(fields)for(let prop in fields){let value=fields[prop];value instanceof StateField&&(result[prop]=value.spec.toJSON(this.field(fields[prop]),this))}return result}static fromJSON(json,config={},fields){if(!json||"string"!=typeof json.doc)throw new RangeError("Invalid JSON representation for EditorState");let fieldInit=[];if(fields)for(let prop in fields){let field=fields[prop],
value=json[prop];fieldInit.push(field.init(state=>field.spec.fromJSON(value,state)))}return EditorState.create({doc:json.doc,selection:EditorSelection.fromJSON(json.selection),extensions:config.extensions?fieldInit.concat([config.extensions]):fieldInit})}static create(config={}){let {configuration,values}=Configuration.resolve(config.extensions||[],new Map),doc=config.doc instanceof text$jscomp$0.Text?config.doc:text$jscomp$0.Text.of((config.doc||"").split(configuration.staticFacet(EditorState.lineSeparator)||
DefaultSplit));config=config.selection?config.selection instanceof EditorSelection?config.selection:EditorSelection.single(config.selection.anchor,config.selection.head):EditorSelection.single(0);checkSelection(config,doc.length);configuration.staticFacet(allowMultipleSelections)||(config=config.asSingle());return new EditorState(configuration,doc,config,values)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(readOnly)}phrase(phrase){for(let map of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(map,
phrase))return map[phrase];return phrase}languageDataAt(name,pos,side=-1){let values=[];for(let provider of this.facet(languageData))for(let result of provider(this,pos,side))Object.prototype.hasOwnProperty.call(result,name)&&values.push(result[name]);return values}charCategorizer(at){return makeCategorizer(this.languageDataAt("wordChars",at).join(""))}wordAt(pos){let {text:text$1,from,length}=this.doc.lineAt(pos),cat=this.charCategorizer(pos),start=pos-from;for(pos-=from;0<start;){var prev=text$jscomp$0.findClusterBreak(text$1,
start,!1);if(cat(text$1.slice(prev,start))!=exports.CharCategory.Word)break;start=prev}for(;pos<length;){prev=text$jscomp$0.findClusterBreak(text$1,pos);if(cat(text$1.slice(pos,prev))!=exports.CharCategory.Word)break;pos=prev}return start==pos?null:EditorSelection.range(start+from,pos+from)}}EditorState.allowMultipleSelections=allowMultipleSelections;EditorState.tabSize=Facet.define({combine:values=>values.length?values[0]:4});EditorState.lineSeparator=lineSeparator;EditorState.readOnly=readOnly;
EditorState.phrases=Facet.define();EditorState.languageData=languageData;EditorState.changeFilter=changeFilter;EditorState.transactionFilter=transactionFilter;EditorState.transactionExtender=transactionExtender;Compartment.reconfigure=StateEffect.define();Object.defineProperty(exports,"Text",{enumerable:!0,get:function(){return text$jscomp$0.Text}});exports.Annotation=Annotation;exports.AnnotationType=AnnotationType;exports.ChangeDesc=ChangeDesc;exports.ChangeSet=ChangeSet;exports.Compartment=Compartment;
exports.EditorSelection=EditorSelection;exports.EditorState=EditorState;exports.Facet=Facet;exports.Prec=global;exports.SelectionRange=SelectionRange;exports.StateEffect=StateEffect;exports.StateEffectType=StateEffectType;exports.StateField=StateField;exports.Transaction=Transaction;exports.combineConfig=function(configs,defaults,combine={}){let result={};for(let config of configs)for(let key of Object.keys(config)){configs=config[key];let current=result[key];if(void 0===current)result[key]=configs;
else if(current!==configs&&void 0!==configs)if(Object.hasOwnProperty.call(combine,key))result[key]=combine[key](current,configs);else throw Error("Config merge conflict for field "+key);}for(let key in defaults)void 0===result[key]&&(result[key]=defaults[key]);return result}}
//# sourceMappingURL=module$node_modules$$codemirror$state$dist$index_cjs.js.map
