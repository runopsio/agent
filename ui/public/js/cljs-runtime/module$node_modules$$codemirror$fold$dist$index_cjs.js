shadow$provide.module$node_modules$$codemirror$fold$dist$index_cjs=function(global,require,module,exports){function mapRange(range,mapping){let from=mapping.mapPos(range.from,1);range=mapping.mapPos(range.to,-1);return from>=range?void 0:{from,to:range}}function selectedLines(view){let lines=[];for(let {head}of view.state.selection.ranges)lines.some(l=>l.from<=head&&l.to>=head)||lines.push(view.lineBlockAt(head));return lines}function foldInside(state,from$jscomp$0,to$jscomp$0){var _a;let found=null;
null===(_a=state.field(foldState,!1))||void 0===_a?void 0:_a.between(from$jscomp$0,to$jscomp$0,(from,to)=>{if(!found||found.from>from)found={from,to}});return found}function foldExists(folded,from,to){let found=!1;folded.between(from,from,(a,b)=>{a==from&&b==to&&(found=!0)});return found}function maybeEnable(state$1,other){return state$1.field(foldState,!1)?other:other.concat(state$jscomp$0.StateEffect.appendConfig.of(codeFolding()))}function announceFold(view$1,range,fold=!0){let lineFrom=view$1.state.doc.lineAt(range.from).number;
range=view$1.state.doc.lineAt(range.to).number;return view$jscomp$0.EditorView.announce.of(`${view$1.state.phrase(fold?"Folded lines":"Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${range}.`)}function codeFolding(config){let result=[foldState,baseTheme];config&&result.push(foldConfig.of(config));return result}Object.defineProperty(exports,"__esModule",{value:!0});var state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs"),
language=require("module$node_modules$$codemirror$language$dist$index_cjs"),gutter=require("module$node_modules$$codemirror$gutter$dist$index_cjs"),rangeset=require("module$node_modules$$codemirror$rangeset$dist$index_cjs");const foldEffect=state$jscomp$0.StateEffect.define({map:mapRange}),unfoldEffect=state$jscomp$0.StateEffect.define({map:mapRange}),foldState=state$jscomp$0.StateField.define({create(){return view$jscomp$0.Decoration.none},update(folded,tr){folded=folded.map(tr.changes);for(let e of tr.effects)e.is(foldEffect)&&
!foldExists(folded,e.value.from,e.value.to)?folded=folded.update({add:[foldWidget.range(e.value.from,e.value.to)]}):e.is(unfoldEffect)&&(folded=folded.update({filter:(from,to)=>e.value.from!=from||e.value.to!=to,filterFrom:e.value.from,filterTo:e.value.to}));if(tr.selection){let onSelection=!1,{head}=tr.selection.main;folded.between(head,head,(a,b)=>{a<head&&b>head&&(onSelection=!0)});onSelection&&(folded=folded.update({filterFrom:head,filterTo:head,filter:(a,b)=>b<=head||a>=head}))}return folded},
provide:f=>view$jscomp$0.EditorView.decorations.from(f)});global=view=>{for(let line of selectedLines(view)){let range=language.foldable(view.state,line.from,line.to);if(range)return view.dispatch({effects:maybeEnable(view.state,[foldEffect.of(range),announceFold(view,range)])}),!0}return!1};require=view=>{if(!view.state.field(foldState,!1))return!1;let effects=[];for(let line of selectedLines(view)){let folded=foldInside(view.state,line.from,line.to);folded&&effects.push(unfoldEffect.of(folded),
announceFold(view,folded,!1))}effects.length&&view.dispatch({effects});return 0<effects.length};module=view=>{let {state}=view,effects=[];for(var pos=0;pos<state.doc.length;){pos=view.lineBlockAt(pos);let range=language.foldable(state,pos.from,pos.to);range&&effects.push(foldEffect.of(range));pos=(range?view.lineBlockAt(range.to):pos).to+1}effects.length&&view.dispatch({effects:maybeEnable(view.state,effects)});return!!effects.length};const unfoldAll=view=>{let field=view.state.field(foldState,!1);
if(!field||!field.size)return!1;let effects=[];field.between(0,view.state.doc.length,(from,to)=>{effects.push(unfoldEffect.of({from,to}))});view.dispatch({effects});return!0},foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:global},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:require},{key:"Ctrl-Alt-[",run:module},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,placeholderText:"…"},foldConfig=state$jscomp$0.Facet.define({combine(values){return state$jscomp$0.combineConfig(values,
defaultConfig)}}),foldWidget=view$jscomp$0.Decoration.replace({widget:new class extends view$jscomp$0.WidgetType{toDOM(view){let {state}=view,conf=state.facet(foldConfig),onclick=event=>{var line=view.lineBlockAt(view.posAtDOM(event.target));(line=foldInside(view.state,line.from,line.to))&&view.dispatch({effects:unfoldEffect.of(line)});event.preventDefault()};if(conf.placeholderDOM)return conf.placeholderDOM(view,onclick);let element=document.createElement("span");element.textContent=conf.placeholderText;
element.setAttribute("aria-label",state.phrase("folded code"));element.title=state.phrase("unfold");element.className="cm-foldPlaceholder";element.onclick=onclick;return element}}}),foldGutterDefaults={openText:"⌄",closedText:"›",markerDOM:null,domEventHandlers:{}};class FoldMarker extends gutter.GutterMarker{constructor(config,open){super();this.config=config;this.open=open}eq(other){return this.config==other.config&&this.open==other.open}toDOM(view){if(this.config.markerDOM)return this.config.markerDOM(this.open);
let span=document.createElement("span");span.textContent=this.open?this.config.openText:this.config.closedText;span.title=view.state.phrase(this.open?"Fold line":"Unfold line");return span}}const baseTheme=view$jscomp$0.EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});exports.codeFolding=codeFolding;exports.foldAll=
module;exports.foldCode=global;exports.foldEffect=foldEffect;exports.foldGutter=function(config={}){let fullConfig=Object.assign(Object.assign({},foldGutterDefaults),config),canFold=new FoldMarker(fullConfig,!0),canUnfold=new FoldMarker(fullConfig,!1),markers=view$jscomp$0.ViewPlugin.fromClass(class{constructor(view){this.from=view.viewport.from;this.markers=this.buildMarkers(view)}update(update){if(update.docChanged||update.viewportChanged||update.startState.facet(language.language)!=update.state.facet(language.language)||
update.startState.field(foldState,!1)!=update.state.field(foldState,!1))this.markers=this.buildMarkers(update.view)}buildMarkers(view){let builder=new rangeset.RangeSetBuilder;for(let line of view.viewportLineBlocks){let mark=foldInside(view.state,line.from,line.to)?canUnfold:language.foldable(view.state,line.from,line.to)?canFold:null;mark&&builder.add(line.from,line.from,mark)}return builder.finish()}}),{domEventHandlers}=fullConfig;return[markers,gutter.gutter({class:"cm-foldGutter",markers(view){var _a;
return(null===(_a=view.plugin(markers))||void 0===_a?void 0:_a.markers)||rangeset.RangeSet.empty},initialSpacer(){return new FoldMarker(fullConfig,!1)},domEventHandlers:Object.assign(Object.assign({},domEventHandlers),{click:(view,line,event)=>domEventHandlers.click&&domEventHandlers.click(view,line,event)?!0:(event=foldInside(view.state,line.from,line.to))?(view.dispatch({effects:unfoldEffect.of(event)}),!0):(line=language.foldable(view.state,line.from,line.to))?(view.dispatch({effects:foldEffect.of(line)}),
!0):!1})}),codeFolding()]};exports.foldKeymap=foldKeymap;exports.foldedRanges=function(state){return state.field(foldState,!1)||rangeset.RangeSet.empty};exports.unfoldAll=unfoldAll;exports.unfoldCode=require;exports.unfoldEffect=unfoldEffect}
//# sourceMappingURL=module$node_modules$$codemirror$fold$dist$index_cjs.js.map
