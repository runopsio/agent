{
"version":3,
"file":"module$node_modules$$codemirror$rangeset$dist$index_cjs.js",
"lineCount":32,
"mappings":"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",
"sources":["node_modules/@codemirror/rangeset/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$codemirror$rangeset$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar state = require('@codemirror/state');\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = state.MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* Far */, true), e = this.findIndex(to, 1000000000 /* Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom)\n                        continue;\n                }\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* Far */;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to > to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        var _a;\n        let cursor = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator)).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint <= 0)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++) {\n            let known = inA.get(set.chunk[i]);\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\n                shared.add(set.chunk[i]);\n        }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint, filterPoint = () => true) {\n        this.minPoint = minPoint;\n        this.filterPoint = filterPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexports.Range = Range;\nexports.RangeSet = RangeSet;\nexports.RangeSetBuilder = RangeSetBuilder;\nexports.RangeValue = RangeValue;\n\n};"],
"names":["shadow$provide","global","require","module","exports","cmpRange","a","b","from","value","startSide","lazySort","ranges","length","prev","i","cur","slice","sort","findSharedChunks","textDiff","inA","Map","set","chunk","maxPoint","chunkPos","shared","Set","known","get","mapPos","touchesRange","add","heapBubble","heap","index","childIndex","child","compare","startA","startB","comparator","goto","endB","pos","dPos","diff","to","endSide","end","clipEnd","Math","min","point","eq","sameValues","activeForPoint","comparePoint","active","compareRange","next","remove","array","e","pop","insert","findMinIndex","found","foundPos","Object","defineProperty","state","RangeValue","other","range","Range","prototype","mapMode","MapMode","TrackDel","constructor","Chunk","findIndex","side","startAt","arr","lo","hi","mid","between","offset","f","map","changes","newPos","val","curFrom","curTo","newFrom","mapped","newTo","max","push","RangeSet","nextLayer","empty","last","chunkEnd","isEmpty","size","update","updateSpec","filterFrom","filterTo","filter","of","LayerCursor","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","finishInner","chunks","start","touch","iter","HeapCursor","sets","oldSets","newSets","minPointSize","sharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","indexOf","spans","iterator","_a","cursor","filterPoint","bind","open","openStart","openEnd","span","build","finish","chunkStart","lastTo","lastFrom","setMaxPoint","finishChunk","newArrays","Error","result","layer","skip","minPoint","rank","gotoInner","forward","has","setRangeIndex","top","activeTo","activeRank","minActive","pointRank","pointFrom","removeActive","addActive","trackOpen","wasPoint","trackExtra","nextVal","reverse"]
}
