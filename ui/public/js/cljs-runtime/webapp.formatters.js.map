{"version":3,"sources":["webapp/formatters.cljs"],"mappings":"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","names":["webapp.formatters/comma-string-to-list","roles","cljs.core/empty?","clojure.string.split","clojure.string/replace","webapp.formatters/list-to-comma-string","clojure.string.join","webapp.formatters/replace-empty-space->dash","string","webapp.formatters/replace-dash->underline","webapp.formatters/split-by-colon","value","webapp.formatters/remove-time-from-date","datetime","cljs.core/first","webapp.formatters/convert-query-params->datetime","webapp.formatters/time-elapsed","time","time-in-seconds","units","unit","p1__49996#","cljs.core.drop_while","Math/floor","p1__49997#","t","hours-time","minutes-time","webapp.formatters/time-ago","ts","js/Date","now","diff","p1__50019#","cljs.core/not","p1__50022#"],"sourcesContent":["(ns webapp.formatters\n  (:require [clojure.string :as string]))\n\n(defn comma-string-to-list\n  \"Transform a comma separated string to list\"\n  [roles]\n  (if (empty? roles) []\n      (string/split\n       (string/replace roles #\", | , \" \",\")\n       #\",\")))\n\n(defn list-to-comma-string\n  \"Transform a list into a comma separated string\"\n  [roles]\n  (string/join \", \" roles))\n\n(defn replace-empty-space->dash\n  [string]\n  (string/replace string #\"\\s\" \"-\"))\n\n(defn replace-dash->underline\n  [string]\n  (string/replace string \"-\" \"_\"))\n\n(defn split-by-colon\n  [value]\n  (string/split value #\":\"))\n\n(defn remove-time-from-date\n  \"It's remove the HH:mm:ss from 'yyyy-mm-dd HH:mm:ss' datetime string\"\n  [datetime]\n  (first (string/split datetime #\" \")))\n\n(defn convert-query-params->datetime\n  [datetime]\n  (-> datetime\n      (string/replace \"+\" \" \")\n      (string/replace #\"%3A\" \":\")))\n\n(defn time-elapsed\n  \"PARAMETERS\n  time -> a value in miliseconds\n\n  Returns a string containing a human readable value of time.\n  For instance:\n  - Less than a second\n  - 26 seconds;\n  - 10 minutes;\n  - in case of hours, if it has at least 1 minute, it returns 'X hours and Y minutes', otherwise, it returns 'X hours' only\n  \"\n  [time]\n  (let [time-in-seconds (/ time 1000)\n        units [{:name \"second\" :limit 60 :in-second 1}\n               {:name \"minute\" :limit 3600 :in-second 60}\n               {:name \"hour\" :limit 9999999999 :in-second 3600}]\n        unit (first (drop-while #(>= time-in-seconds (:limit %))\n                                units))]\n    (cond\n      ;; In the miliseconds\n      (< time-in-seconds 1)\n      \"less than a second\"\n      ;; Simpler response in case the response is in less than an hour\n      (and (>= time-in-seconds 1) (< time-in-seconds 3600))\n      (-> (/ time-in-seconds (:in-second unit))\n          Math/floor\n          int\n          (#(str % \" \" (:name unit) (when (> % 1) \"s\"))))\n      ;; Response has more than one hour\n      :else (let [t (/ time-in-seconds (:in-second unit))\n                  hours-time (int (Math/floor t))\n                  minutes-time (int (Math/floor (* (- t hours-time) 60)))]\n              (str hours-time \" \" (:name unit) (when (> hours-time 1) \"s\")\n                   (when (>= minutes-time 1)\n                     (str \" and \" minutes-time \" minute\"\n                          (when (> minutes-time 1) \"s\"))))))))\n\n(defn time-ago\n  \"It receives our Runops API date format, a simple string containing YYYY/MM/DD HH:MM\n  and parses to a readable string containing `x time ago`, for instance:\n  - 10 minutes ago\n  - 1 hour ago\n\n  Important: `time` parameters will always be assumed as UTC timezone, so make sure you're passing a UTC timezone date formatted as `YYYY/MM/DD HH:MM` in here.\n  \"\n  [time]\n  (let [units [{:name \"second\" :limit 60 :in-second 1}\n               {:name \"minute\" :limit 3600 :in-second 60}\n               {:name \"hour\" :limit 86400 :in-second 3600}\n               {:name \"day\" :limit 604800 :in-second 86400}\n               {:name \"week\" :limit 2629743 :in-second 604800}\n               {:name \"month\" :limit 31556926 :in-second 2629743}\n               {:name \"year\" :limit 99999999999999 :in-second 31556926}]\n        ts (/ (.parse js/Date (str time \" UTC\")) 1000)\n        now (/ (.getTime (new js/Date)) 1000)\n        diff (- now ts)]\n    (if (< diff 30)\n      \"just now\"\n      (let [unit (first (drop-while #(or (>= diff (:limit %))\n                                         (not (:limit %)))\n                                    units))]\n        (-> (/ diff (:in-second unit))\n            Math/floor\n            int\n            (#(str % \" \" (:name unit) (when (> % 1) \"s\") \" ago\")))))))\n"]}