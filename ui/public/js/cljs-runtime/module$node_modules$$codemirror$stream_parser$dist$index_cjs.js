shadow$provide.module$node_modules$$codemirror$stream_parser$dist$index_cjs=function(global,require,module,exports){function countCol(string,end,tabSize,startIndex=0,startValue=0){null==end&&(end=string.search(/[^\s\u00a0]/),-1==end&&(end=string.length));for(;startIndex<end;startIndex++)9==string.charCodeAt(startIndex)?startValue+=tabSize-startValue%tabSize:startValue++;return startValue}function fullParser(spec){return{token:spec.token,blankLine:spec.blankLine||(()=>{}),startState:spec.startState||
(()=>!0),copyState:spec.copyState||defaultCopyState,indent:spec.indent||(()=>null),languageData:spec.languageData||{},tokenTable:spec.tokenTable||noTokens}}function defaultCopyState(state){if("object"!=typeof state)return state;let newState={};for(let prop in state){let val=state[prop];newState[prop]=val instanceof Array?val.slice():val}return newState}function findState(lang,tree,off,startPos,before){var state=off>=startPos&&off+tree.length<=before&&tree.prop(lang.stateAfter);if(state)return{state:lang.streamParser.copyState(state),
pos:off+tree.length};for(state=tree.children.length-1;0<=state;state--){var child=tree.children[state];let pos=off+tree.positions[state];if(child=child instanceof common.Tree&&pos<before&&findState(lang,child,pos,startPos,before))return child}return null}function cutTree(lang,tree,from,to,inside){if(inside&&0>=from&&to>=tree.length)return tree;inside||tree.type!=lang.topNode||(inside=!0);for(let i=tree.children.length-1;0<=i;i--){let pos=tree.positions[i],child=tree.children[i];if(pos<to&&child instanceof
common.Tree){if(!(lang=cutTree(lang,child,from-pos,to-pos,inside)))break;return inside?new common.Tree(tree.type,tree.children.slice(0,i).concat(lang),tree.positions.slice(0,i+1),pos+lang.length):lang}}return null}function readToken(token,stream,state){stream.start=stream.pos;for(let i=0;10>i;i++){let result=token(stream,state);if(stream.pos>stream.start)return result}throw Error("Stream parser failed to advance stream.");}function warnForPart(part,msg){-1<warned.indexOf(part)||(warned.push(part),
console.warn(msg))}function createTokenType(extra,tagStr){var tag=null;for(let part of tagStr.split(".")){let value=extra[part]||highlight.tags[part];value?"function"==typeof value?tag?tag=value(tag):warnForPart(part,`Modifier ${part} used at start of tag`):tag?warnForPart(part,`Tag ${part} used as modifier`):tag=value:warnForPart(part,`Unknown highlighting tag ${part}`)}if(!tag)return 0;extra=tagStr.replace(/ /g,"_");tag=common.NodeType.define({id:typeArray.length,name:extra,props:[highlight.styleTags({[extra]:tag})]});
typeArray.push(tag);return tag.id}function docID(data){let type=common.NodeType.define({id:typeArray.length,name:"Document",props:[language.languageDataProp.add(()=>data)]});typeArray.push(type);return type}Object.defineProperty(exports,"__esModule",{value:!0});var common=require("module$node_modules$$lezer$common$dist$index_cjs"),highlight=require("module$node_modules$$codemirror$highlight$dist$index_cjs"),language=require("module$node_modules$$codemirror$language$dist$index_cjs");class StringStream{constructor(string,
tabSize,indentUnit){this.string=string;this.tabSize=tabSize;this.indentUnit=indentUnit;this.lastColumnValue=this.lastColumnPos=this.start=this.pos=0}eol(){return this.pos>=this.string.length}sol(){return 0==this.pos}peek(){return this.string.charAt(this.pos)||void 0}next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}eat(match){let ch=this.string.charAt(this.pos);if("string"==typeof match?ch==match:ch&&(match instanceof RegExp?match.test(ch):match(ch)))return++this.pos,ch}eatWhile(match){let start=
this.pos;for(;this.eat(match););return this.pos>start}eatSpace(){let start=this.pos;for(;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>start}skipToEnd(){this.pos=this.string.length}skipTo(ch){ch=this.string.indexOf(ch,this.pos);if(-1<ch)return this.pos=ch,!0}backUp(n){this.pos-=n}column(){this.lastColumnPos<this.start&&(this.lastColumnValue=countCol(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start);return this.lastColumnValue}indentation(){return countCol(this.string,
null,this.tabSize)}match(pattern,consume,caseInsensitive){if("string"==typeof pattern){var JSCompiler_inline_result=this.string.substr(this.pos,pattern.length);JSCompiler_inline_result=caseInsensitive?JSCompiler_inline_result.toLowerCase():JSCompiler_inline_result;caseInsensitive=caseInsensitive?pattern.toLowerCase():pattern;return JSCompiler_inline_result==caseInsensitive?(!1!==consume&&(this.pos+=pattern.length),!0):null}if((pattern=this.string.slice(this.pos).match(pattern))&&0<pattern.index)return null;
pattern&&!1!==consume&&(this.pos+=pattern[0].length);return pattern}current(){return this.string.slice(this.start,this.pos)}}class StreamLanguage extends language.Language{constructor(parser){let data=language.defineLanguageFacet(parser.languageData),p=fullParser(parser),self,impl=new class extends common.Parser{createParse(input,fragments,ranges){return new Parse(self,input,fragments,ranges)}};super(data,impl,docID(data),[language.indentService.of((cx,pos)=>this.getIndent(cx,pos))]);self=this;this.streamParser=
p;this.stateAfter=new common.NodeProp({perNode:!0});this.tokenTable=parser.tokenTable?new TokenTable(p.tokenTable):defaultTokenTable}static define(spec){return new StreamLanguage(spec)}getIndent(cx,pos){for(var tree=language.syntaxTree(cx.state),at=tree.resolve(pos);at&&at.type!=this.topNode;)at=at.parent;if(!at)return null;(at=findState(this,tree,0,at.from,pos))?(tree=at.state,at=at.pos+1):(tree=this.streamParser.startState(cx.unit),at=0);if(1E4<pos-at)return null;for(;at<pos;){at=cx.state.doc.lineAt(at);
let end=Math.min(pos,at.to);if(at.length){let stream=new StringStream(at.text,cx.state.tabSize,cx.unit);for(;stream.pos<end-at.from;)readToken(this.streamParser.token,stream,tree)}else this.streamParser.blankLine(tree,cx.unit);if(end==pos)break;at=at.to+1}({text:pos}=cx.state.doc.lineAt(pos));return this.streamParser.indent(tree,/^\s*(.*)/.exec(pos)[1],cx)}get allowsNesting(){return!1}}class Parse{constructor(lang,input,fragments,ranges){this.lang=lang;this.input=input;this.fragments=fragments;this.ranges=
ranges;this.stoppedAt=null;this.chunks=[];this.chunkPos=[];this.chunk=[];this.chunkReused=void 0;this.rangeIndex=0;this.to=ranges[ranges.length-1].to;input=language.ParseContext.get();ranges=ranges[0].from;a:{var editorState=null===input||void 0===input?void 0:input.state;for(let f of fragments){fragments=f.to-(f.openEnd?25:0);fragments=f.from+(f.openStart?25:0)<=ranges&&fragments>ranges&&findState(lang,f.tree,0-f.offset,ranges,fragments);let tree;if(fragments&&(tree=cutTree(lang,f.tree,ranges+f.offset,
fragments.pos+f.offset,!1))){lang={state:fragments.state,tree};break a}}lang={state:lang.streamParser.startState(editorState?language.getIndentUnit(editorState):4),tree:common.Tree.empty}}let {state,tree:tree$jscomp$0}=lang;this.state=state;this.parsedPos=this.chunkStart=ranges+tree$jscomp$0.length;for(lang=0;lang<tree$jscomp$0.children.length;lang++)this.chunks.push(tree$jscomp$0.children[lang]),this.chunkPos.push(tree$jscomp$0.positions[lang]);input&&this.parsedPos<input.viewport.from-1E5&&(this.state=
this.lang.streamParser.startState(language.getIndentUnit(input.state)),input.skipUntilInView(this.parsedPos,input.viewport.from),this.parsedPos=input.viewport.from)}advance(){let context=language.ParseContext.get(),parseEnd=null==this.stoppedAt?this.to:Math.min(this.to,this.stoppedAt),end=Math.min(parseEnd,this.chunkStart+2048);for(context&&(end=Math.min(end,context.viewport.to));this.parsedPos<end;)this.parseLine(context);this.chunkStart<this.parsedPos&&this.finishChunk();return this.parsedPos>=
parseEnd?this.finish():context&&this.parsedPos>=context.viewport.to?(context.skipUntilInView(this.parsedPos,parseEnd),this.finish()):null}stopAt(pos){this.stoppedAt=pos}lineAfter(pos){let chunk=this.input.chunk(pos);if(this.input.lineChunks)"\n"==chunk&&(chunk="");else{let eol=chunk.indexOf("\n");-1<eol&&(chunk=chunk.slice(0,eol))}return pos+chunk.length<=this.to?chunk:chunk.slice(0,this.to-pos)}nextLine(){var from=this.parsedPos;let line=this.lineAfter(from);var end=from+line.length;for(from=this.rangeIndex;;){var rangeEnd=
this.ranges[from].to;if(rangeEnd>=end)break;line=line.slice(0,rangeEnd-(end-line.length));from++;if(from==this.ranges.length)break;end=this.ranges[from].from;rangeEnd=this.lineAfter(end);line+=rangeEnd;end+=rangeEnd.length}return{line,end}}skipGapsTo(pos,offset,side){for(;;){let end=this.ranges[this.rangeIndex].to;var offPos=pos+offset;if(0<side?end>offPos:end>=offPos)break;offPos=this.ranges[++this.rangeIndex].from;offset+=offPos-end}return offset}emitToken(id,from,to,size,offset){if(1<this.ranges.length){offset=
this.skipGapsTo(from,offset,1);from+=offset;let len0=this.chunk.length;offset=this.skipGapsTo(to,offset,-1);to+=offset;size+=this.chunk.length-len0}this.chunk.push(id,from,to,size);return offset}parseLine(context){let {line,end}=this.nextLine(),offset=0,{streamParser}=this.lang;context=new StringStream(line,context?context.state.tabSize:4,context?language.getIndentUnit(context.state):2);if(context.eol())streamParser.blankLine(this.state,context.indentUnit);else for(;!context.eol();){let token=readToken(streamParser.token,
context,this.state);token&&(offset=this.emitToken(this.lang.tokenTable.resolve(token),this.parsedPos+context.start,this.parsedPos+context.pos,4,offset));if(1E4<context.start)break}this.parsedPos=end;this.parsedPos<this.to&&this.parsedPos++}finishChunk(){let tree=common.Tree.build({buffer:this.chunk,start:this.chunkStart,length:this.parsedPos-this.chunkStart,nodeSet,topID:0,maxBufferLength:2048,reused:this.chunkReused});tree=new common.Tree(tree.type,tree.children,tree.positions,tree.length,[[this.lang.stateAfter,
this.lang.streamParser.copyState(this.state)]]);this.chunks.push(tree);this.chunkPos.push(this.chunkStart-this.ranges[0].from);this.chunk=[];this.chunkReused=void 0;this.chunkStart=this.parsedPos}finish(){return(new common.Tree(this.lang.topNode,this.chunks,this.chunkPos,this.parsedPos-this.ranges[0].from)).balance()}}const noTokens=Object.create(null),typeArray=[common.NodeType.none],nodeSet=new common.NodeSet(typeArray),warned=[],defaultTable=Object.create(null);for(let [legacyName,name]of[["variable",
"variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","typeName"],["attribute","propertyName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])defaultTable[legacyName]=createTokenType(noTokens,name);class TokenTable{constructor(extra){this.extra=extra;this.table=Object.assign(Object.create(null),defaultTable)}resolve(tag){return tag?
this.table[tag]||(this.table[tag]=createTokenType(this.extra,tag)):0}}const defaultTokenTable=new TokenTable(noTokens);exports.StreamLanguage=StreamLanguage;exports.StringStream=StringStream}
//# sourceMappingURL=module$node_modules$$codemirror$stream_parser$dist$index_cjs.js.map
