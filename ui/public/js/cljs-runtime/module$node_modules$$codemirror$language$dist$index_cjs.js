shadow$provide.module$node_modules$$codemirror$language$dist$index_cjs=function(global,require,module,exports){function defineLanguageFacet(baseData){return state$jscomp$0.Facet.define({combine:baseData?values=>values.concat(baseData):void 0})}function languageDataFacetAt(state,pos,side){let topLang=state.facet(language$jscomp$0);if(!topLang)return null;let facet=topLang.data;if(topLang.allowsNesting)for(state=syntaxTree(state).topNode;state;state=state.enter(pos,side,!0,!1))facet=state.type.prop(languageDataProp)||
facet;return facet}function syntaxTree(state){return(state=state.field(Language.state,!1))?state.tree:common.Tree.empty}function cutFragments(fragments,from,to){return common.TreeFragment.applyChanges(fragments,[{fromA:from,toA:to,fromB:from,toB:to}])}function getIndentUnit(state){let unit=state.facet(indentUnit);return 9==unit.charCodeAt(0)?state.tabSize*unit.length:unit.length}function indentString(state,cols){let result="",ts=state.tabSize;if(9==state.facet(indentUnit).charCodeAt(0))for(;cols>=
ts;)result+="\t",cols-=ts;for(state=0;state<cols;state++)result+=" ";return result}function getIndentation(context,pos){context instanceof state$jscomp$0.EditorState&&(context=new IndentContext(context));for(var service of context.state.facet(indentService)){let result=service(context,pos);if(null!=result)return result}return pos=(service=syntaxTree(context.state))?indentFrom(service.resolveInner(pos).enterUnfinishedNodesBefore(pos),pos,context):null}function indentStrategy(tree){var strategy=tree.type.prop(indentNodeProp);
if(strategy)return strategy;strategy=tree.firstChild;let close;if(strategy&&(close=strategy.type.prop(common.NodeProp.closedBy))){let last=tree.lastChild,closed=last&&-1<close.indexOf(last.name);return cx=>delimitedStrategy(cx,!0,1,void 0,!closed||cx.pos==cx.options.simulateBreak&&cx.options.simulateDoubleBreak?void 0:last.from)}return null==tree.parent?topIndent:null}function indentFrom(node,pos,base){for(;node;node=node.parent){let strategy=indentStrategy(node);if(strategy)return strategy(new TreeIndentContext(base,
pos,node))}return null}function topIndent(){return 0}function delimitedStrategy(context,align,units,closing,closedAt){var after=context.textAfter,space=after.match(/^\s*/)[0].length;closing=closing&&after.slice(space,space+closing.length)==closing||closedAt==context.pos+space;if(align)a:if(align=context.node,closedAt=align.childAfter(align.from),after=align.lastChild,closedAt){space=context.options.simulateBreak;var openLine=context.state.doc.lineAt(closedAt.from);space=null==space||space<=openLine.from?
openLine.to:Math.min(openLine.to,space);for(openLine=closedAt.to;;){openLine=align.childAfter(openLine);if(!openLine||openLine==after){align=null;break a}if(!openLine.type.isSkipped){align=openLine.from<space?closedAt:null;break a}openLine=openLine.to}}else align=null;else align=null;return align?closing?context.column(align.from):context.column(align.to):context.baseIndent+(closing?0:context.unit*units)}Object.defineProperty(exports,"__esModule",{value:!0});var common=require("module$node_modules$$lezer$common$dist$index_cjs"),
state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs"),text$jscomp$0=require("module$node_modules$$codemirror$text$dist$index_cjs");const languageDataProp=new common.NodeProp;class Language{constructor(data,parser,topNode,extraExtensions=[]){this.data=data;this.topNode=topNode;state$jscomp$0.EditorState.prototype.hasOwnProperty("tree")||Object.defineProperty(state$jscomp$0.EditorState.prototype,"tree",
{get(){return syntaxTree(this)}});this.parser=parser;this.extension=[language$jscomp$0.of(this),state$jscomp$0.EditorState.languageData.of((state,pos,side)=>state.facet(languageDataFacetAt(state,pos,side)))].concat(extraExtensions)}isActiveAt(state,pos,side=-1){return languageDataFacetAt(state,pos,side)==this.data}findRegions(state){let lang=state.facet(language$jscomp$0);if((null===lang||void 0===lang?void 0:lang.data)==this.data)return[{from:0,to:state.doc.length}];if(!lang||!lang.allowsNesting)return[];
let result=[],explore=(tree,from)=>{if(tree.prop(languageDataProp)==this.data)result.push({from,to:from+tree.length});else{var mount=tree.prop(common.NodeProp.mounted);if(mount){if(mount.tree.prop(languageDataProp)==this.data){if(mount.overlay)for(var r of mount.overlay)result.push({from:r.from+from,to:r.to+from});else result.push({from,to:from+tree.length});return}if(mount.overlay&&(r=result.length,explore(mount.tree,mount.overlay[0].from+from),result.length>r))return}for(mount=0;mount<tree.children.length;mount++)r=
tree.children[mount],r instanceof common.Tree&&explore(r,tree.positions[mount]+from)}};explore(syntaxTree(state),0);return result}get allowsNesting(){return!0}}Language.setState=state$jscomp$0.StateEffect.define();class LRLanguage extends Language{constructor(data,parser){super(data,parser,parser.topNode);this.parser=parser}static define(spec){let data=defineLanguageFacet(spec.languageData);return new LRLanguage(data,spec.parser.configure({props:[languageDataProp.add(type=>type.isTop?data:void 0)]}))}configure(options){return new LRLanguage(this.data,
this.parser.configure(options))}get allowsNesting(){return 0<this.parser.wrappers.length}}class DocInput{constructor(doc,length=doc.length){this.doc=doc;this.length=length;this.cursorPos=0;this.string="";this.cursor=doc.iter()}syncTo(pos){this.string=this.cursor.next(pos-this.cursorPos).value;this.cursorPos=pos+this.string.length;return this.cursorPos-this.string.length}chunk(pos){this.syncTo(pos);return this.string}get lineChunks(){return!0}read(from,to){let stringStart=this.cursorPos-this.string.length;
return from<stringStart||to>=this.cursorPos?this.doc.sliceString(from,to):this.string.slice(from-stringStart,to-stringStart)}}let currentContext=null;class ParseContext{constructor(parser,state,fragments=[],tree,treeLen,viewport,skipped,scheduleOn){this.parser=parser;this.state=state;this.fragments=fragments;this.tree=tree;this.treeLen=treeLen;this.viewport=viewport;this.skipped=skipped;this.scheduleOn=scheduleOn;this.parse=null;this.tempSkipped=[]}startParse(){return this.parser.startParse(new DocInput(this.state.doc),
this.fragments)}work(time,upto){null!=upto&&upto>=this.state.doc.length&&(upto=void 0);return this.tree!=common.Tree.empty&&this.isDone(null!==upto&&void 0!==upto?upto:this.state.doc.length)?(this.takeTree(),!0):this.withContext(()=>{var _a;let endTime=Date.now()+time;this.parse||(this.parse=this.startParse());for(null!=upto&&(null==this.parse.stoppedAt||this.parse.stoppedAt>upto)&&upto<this.state.doc.length&&this.parse.stopAt(upto);;){let done=this.parse.advance();if(done)if(this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(done,
this.fragments,null!=this.parse.stoppedAt)),this.treeLen=null!==(_a=this.parse.stoppedAt)&&void 0!==_a?_a:this.state.doc.length,this.tree=done,this.parse=null,this.treeLen<(null!==upto&&void 0!==upto?upto:this.state.doc.length))this.parse=this.startParse();else return!0;if(Date.now()>endTime)return!1}})}takeTree(){let pos,tree;this.parse&&(pos=this.parse.parsedPos)>=this.treeLen&&((null==this.parse.stoppedAt||this.parse.stoppedAt>pos)&&this.parse.stopAt(pos),this.withContext(()=>{for(;!(tree=this.parse.advance()););
}),this.treeLen=pos,this.tree=tree,this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(this.tree,this.fragments,!0)),this.parse=null)}withContext(f){let prev=currentContext;currentContext=this;try{return f()}finally{currentContext=prev}}withoutTempSkipped(fragments){for(let r;r=this.tempSkipped.pop();)fragments=cutFragments(fragments,r.from,r.to);return fragments}changes(changes,newState){let {fragments,tree,treeLen,viewport,skipped}=this;this.takeTree();if(!changes.empty){let ranges=
[];changes.iterChangedRanges((fromA,toA,fromB,toB)=>ranges.push({fromA,toA,fromB,toB}));fragments=common.TreeFragment.applyChanges(fragments,ranges);tree=common.Tree.empty;treeLen=0;viewport={from:changes.mapPos(viewport.from,-1),to:changes.mapPos(viewport.to,1)};if(this.skipped.length){skipped=[];for(let r of this.skipped){let from=changes.mapPos(r.from,1),to=changes.mapPos(r.to,-1);from<to&&skipped.push({from,to})}}}return new ParseContext(this.parser,newState,fragments,tree,treeLen,viewport,skipped,
this.scheduleOn)}updateViewport(viewport){if(this.viewport.from==viewport.from&&this.viewport.to==viewport.to)return!1;this.viewport=viewport;let startLen=this.skipped.length;for(let i=0;i<this.skipped.length;i++){let {from,to}=this.skipped[i];from<viewport.to&&to>viewport.from&&(this.fragments=cutFragments(this.fragments,from,to),this.skipped.splice(i--,1))}if(this.skipped.length>=startLen)return!1;this.reset();return!0}reset(){this.parse&&(this.takeTree(),this.parse=null)}skipUntilInView(from,to){this.skipped.push({from,
to})}static getSkippingParser(until){return new class extends common.Parser{createParse(input,fragments,ranges){let from=ranges[0].from,to=ranges[ranges.length-1].to;return{parsedPos:from,advance(){let cx=currentContext;if(cx){for(let r of ranges)cx.tempSkipped.push(r);until&&(cx.scheduleOn=cx.scheduleOn?Promise.all([cx.scheduleOn,until]):until)}this.parsedPos=to;return new common.Tree(common.NodeType.none,[],[],to-from)},stoppedAt:null,stopAt(){}}}}}isDone(upto){upto=Math.min(upto,this.state.doc.length);
let frags=this.fragments;return this.treeLen>=upto&&frags.length&&0==frags[0].from&&frags[0].to>=upto}static get(){return currentContext}}class LanguageState{constructor(context){this.context=context;this.tree=context.tree}apply(tr){if(!tr.docChanged)return this;let newCx=this.context.changes(tr.changes,tr.state);tr=this.context.treeLen==tr.startState.doc.length?void 0:Math.max(tr.changes.mapPos(this.context.treeLen),newCx.viewport.to);newCx.work(20,tr)||newCx.takeTree();return new LanguageState(newCx)}static init(state){let vpTo=
Math.min(3E3,state.doc.length);state=new ParseContext(state.facet(language$jscomp$0).parser,state,[],common.Tree.empty,0,{from:0,to:vpTo},[],null);state.work(20,vpTo)||state.takeTree();return new LanguageState(state)}}Language.state=state$jscomp$0.StateField.define({create:LanguageState.init,update(value,tr){for(let e of tr.effects)if(e.is(Language.setState))return e.value;return tr.startState.facet(language$jscomp$0)!=tr.state.facet(language$jscomp$0)?LanguageState.init(tr.state):value.apply(tr)}});
let requestIdle=callback=>{let timeout=setTimeout(()=>callback(),500);return()=>clearTimeout(timeout)};"undefined"!=typeof requestIdleCallback&&(requestIdle=callback=>{let idle=-1,timeout=setTimeout(()=>{idle=requestIdleCallback(callback,{timeout:400})},100);return()=>0>idle?clearTimeout(timeout):cancelIdleCallback(idle)});const parseWorker=view$jscomp$0.ViewPlugin.fromClass(class{constructor(view){this.view=view;this.working=null;this.workScheduled=0;this.chunkBudget=this.chunkEnd=-1;this.work=this.work.bind(this);
this.scheduleWork()}update(update){let cx=this.view.state.field(Language.state).context;(cx.updateViewport(update.view.viewport)||this.view.viewport.to>cx.treeLen)&&this.scheduleWork();update.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork());this.checkAsyncSchedule(cx)}scheduleWork(){if(!this.working){var {state}=this.view,field=state.field(Language.state);field.tree==field.context.tree&&field.context.isDone(state.doc.length)||(this.working=requestIdle(this.work))}}work(deadline){this.working=
null;let now=Date.now();this.chunkEnd<now&&(0>this.chunkEnd||this.view.hasFocus)&&(this.chunkEnd=now+3E4,this.chunkBudget=3E3);if(!(0>=this.chunkBudget)){var {state,viewport:{to:vpTo}}=this.view,field=state.field(Language.state);if(field.tree!=field.context.tree||!field.context.isDone(vpTo+1E5)){var time=Math.min(this.chunkBudget,100,deadline?Math.max(25,deadline.timeRemaining()-5):1E9);deadline=field.context.treeLen<vpTo&&state.doc.length>vpTo+1E3;time=field.context.work(time,vpTo+(deadline?0:1E5));
this.chunkBudget-=Date.now()-now;if(time||0>=this.chunkBudget)field.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(field.context))});0<this.chunkBudget&&(!time||deadline)&&this.scheduleWork();this.checkAsyncSchedule(field.context)}}}checkAsyncSchedule(cx){cx.scheduleOn&&(this.workScheduled++,cx.scheduleOn.then(()=>this.scheduleWork()).catch(err=>view$jscomp$0.logException(this.view.state,err)).then(()=>this.workScheduled--),cx.scheduleOn=null)}destroy(){this.working&&
this.working()}isWorking(){return this.working||0<this.workScheduled}},{eventHandlers:{focus(){this.scheduleWork()}}}),language$jscomp$0=state$jscomp$0.Facet.define({combine(languages){return languages.length?languages[0]:null},enables:[Language.state,parseWorker]});class LanguageSupport{constructor(language,support=[]){this.language=language;this.support=support;this.extension=[language,support]}}class LanguageDescription{constructor(name,alias,extensions,filename,loadFunc,support){this.name=name;
this.alias=alias;this.extensions=extensions;this.filename=filename;this.loadFunc=loadFunc;this.support=support;this.loading=null}load(){return this.loading||(this.loading=this.loadFunc().then(support=>this.support=support,err=>{this.loading=null;throw err;}))}static of(spec){let {load,support}=spec;if(!load){if(!support)throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");load=()=>Promise.resolve(support)}return new LanguageDescription(spec.name,(spec.alias||[]).concat(spec.name).map(s=>
s.toLowerCase()),spec.extensions||[],spec.filename,load,support)}static matchFilename(descs,filename){for(let d of descs)if(d.filename&&d.filename.test(filename))return d;if(filename=/\.([^.]+)$/.exec(filename))for(let d of descs)if(-1<d.extensions.indexOf(filename[1]))return d;return null}static matchLanguageName(descs,name,fuzzy=!0){name=name.toLowerCase();for(let d of descs)if(d.alias.some(a=>a==name))return d;if(fuzzy)for(let d of descs)for(let a of d.alias)if(descs=name.indexOf(a),-1<descs&&
(2<a.length||!/\w/.test(name[descs-1])&&!/\w/.test(name[descs+a.length])))return d;return null}}const indentService=state$jscomp$0.Facet.define(),indentUnit=state$jscomp$0.Facet.define({combine:values=>{if(!values.length)return"  ";if(!/^(?: +|\t+)$/.test(values[0]))throw Error("Invalid indent unit: "+JSON.stringify(values[0]));return values[0]}});class IndentContext{constructor(state,options={}){this.state=state;this.options=options;this.unit=getIndentUnit(state)}lineAt(pos,bias=1){let line=this.state.doc.lineAt(pos),
{simulateBreak}=this.options;return null!=simulateBreak&&simulateBreak>=line.from&&simulateBreak<=line.to?(0>bias?simulateBreak<pos:simulateBreak<=pos)?{text:line.text.slice(simulateBreak-line.from),from:simulateBreak}:{text:line.text.slice(0,simulateBreak-line.from),from:line.from}:line}textAfterPos(pos,bias=1){if(this.options.simulateDoubleBreak&&pos==this.options.simulateBreak)return"";let {text,from}=this.lineAt(pos,bias);return text.slice(pos-from,Math.min(text.length,pos+100-from))}column(pos,
bias=1){let {text,from}=this.lineAt(pos,bias);pos=this.countColumn(text,pos-from);bias=this.options.overrideIndentation?this.options.overrideIndentation(from):-1;-1<bias&&(pos+=bias-this.countColumn(text,text.search(/\S|$/)));return pos}countColumn(line,pos=line.length){return text$jscomp$0.countColumn(line,this.state.tabSize,pos)}lineIndent(pos,bias=1){let {text,from}=this.lineAt(pos,bias);if(pos=this.options.overrideIndentation)if(pos=pos(from),-1<pos)return pos;return this.countColumn(text,text.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||
null}}const indentNodeProp=new common.NodeProp;class TreeIndentContext extends IndentContext{constructor(base,pos,node){super(base.state,base.options);this.base=base;this.pos=pos;this.node=node}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let line=this.state.doc.lineAt(this.node.from);for(;;){let atBreak=this.node.resolve(line.from);for(;atBreak.parent&&atBreak.parent.from==atBreak.from;)atBreak=atBreak.parent;var JSCompiler_inline_result;a:{for(JSCompiler_inline_result=this.node;JSCompiler_inline_result;JSCompiler_inline_result=
JSCompiler_inline_result.parent)if(atBreak==JSCompiler_inline_result){JSCompiler_inline_result=!0;break a}JSCompiler_inline_result=!1}if(JSCompiler_inline_result)break;line=this.state.doc.lineAt(atBreak.from)}return this.lineIndent(line.from)}continue(){let parent=this.node.parent;return parent?indentFrom(parent,this.pos,this.base):0}}const foldService=state$jscomp$0.Facet.define(),foldNodeProp=new common.NodeProp;exports.IndentContext=IndentContext;exports.LRLanguage=LRLanguage;exports.Language=
Language;exports.LanguageDescription=LanguageDescription;exports.LanguageSupport=LanguageSupport;exports.ParseContext=ParseContext;exports.TreeIndentContext=TreeIndentContext;exports.continuedIndent=function({except,units=1}={}){return context=>{let matchExcept=except&&except.test(context.textAfter);return context.baseIndent+(matchExcept?0:units*context.unit)}};exports.defineLanguageFacet=defineLanguageFacet;exports.delimitedIndent=function({closing,align=!0,units=1}){return context=>delimitedStrategy(context,
align,units,closing)};exports.ensureSyntaxTree=function(state,upto,timeout=50){var _a;return(state=null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context)?state.isDone(upto)||state.work(timeout,upto)?state.tree:null:null};exports.flatIndent=context=>context.baseIndent;exports.foldInside=function(node){let first=node.firstChild,last=node.lastChild;return first&&first.to<last.from?{from:first.to,to:last.type.isError?node.to:last.from}:null};exports.foldNodeProp=foldNodeProp;exports.foldService=
foldService;exports.foldable=function(state,lineStart,lineEnd){for(var service of state.facet(foldService)){var result=service(state,lineStart,lineEnd);if(result)return result}service=syntaxTree(state);if(0==service.length)state=null;else{result=service.resolveInner(lineEnd);for(service=null;result;result=result.parent)if(!(result.to<=lineEnd||result.from>lineEnd)){if(service&&result.from<lineStart)break;var prop=result.type.prop(foldNodeProp);prop&&(prop=prop(result,state))&&prop.from<=lineEnd&&
prop.from>=lineStart&&prop.to>lineEnd&&(service=prop)}state=service}return state};exports.getIndentUnit=getIndentUnit;exports.getIndentation=getIndentation;exports.indentNodeProp=indentNodeProp;exports.indentOnInput=function(){return state$jscomp$0.EditorState.transactionFilter.of(tr=>{if(!tr.docChanged||!tr.isUserEvent("input.type"))return tr;var rules=tr.startState.languageDataAt("indentOnInput",tr.startState.selection.main.head);if(!rules.length)return tr;var doc=tr.newDoc,{head:head$jscomp$0}=
tr.newSelection.main,line=doc.lineAt(head$jscomp$0);if(head$jscomp$0>line.from+200)return tr;let lineStart=doc.sliceString(line.from,head$jscomp$0);if(!rules.some(r=>r.test(lineStart)))return tr;({state:rules}=tr);doc=-1;head$jscomp$0=[];for(let {head}of rules.selection.ranges){line=rules.doc.lineAt(head);if(line.from==doc)continue;doc=line.from;var indent=getIndentation(rules,line.from);if(null==indent)continue;let cur=/^\s*/.exec(line.text)[0];indent=indentString(rules,indent);cur!=indent&&head$jscomp$0.push({from:line.from,
to:line.from+cur.length,insert:indent})}return head$jscomp$0.length?[tr,{changes:head$jscomp$0,sequential:!0}]:tr})};exports.indentService=indentService;exports.indentString=indentString;exports.indentUnit=indentUnit;exports.language=language$jscomp$0;exports.languageDataProp=languageDataProp;exports.syntaxParserRunning=function(view){var _a;return(null===(_a=view.plugin(parseWorker))||void 0===_a?void 0:_a.isWorking())||!1};exports.syntaxTree=syntaxTree;exports.syntaxTreeAvailable=function(state,
upto=state.doc.length){var _a;return(null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context.isDone(upto))||!1}}
//# sourceMappingURL=module$node_modules$$codemirror$language$dist$index_cjs.js.map
