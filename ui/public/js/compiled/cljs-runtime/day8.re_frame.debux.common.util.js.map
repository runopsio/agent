{"version":3,"sources":["day8/re_frame/debux/common/util.cljc"],"mappings":"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","names":["day8.re-frame.debux.common.util/map->seq","m","cljs.core.reduce","p__75632","vec__75633","cljs.core.nth","r","k","v","cljs.core.concat","day8.re-frame.debux.common.util/sequential-zip","root","p1__75636#","clojure.zip/zipper","cljs.core/sequential?","cljs.core/map?","x","cljs.core/with-meta","cljs.core/meta","children","cljs.core/vector?","cljs.core/vec","p__75637","vec__75638","cljs.core.assoc","cljs.core.partition","day8.re-frame.debux.common.util/right-or-next","loc","temp__5751__auto__","right","clojure.zip/right","clojure.zip/node","rightmost","clojure.zip/down","clojure.zip/rightmost","clojure.zip/next","day8.re-frame.debux.common.util/auto-gensym-pattern","day8.re-frame.debux.common.util/anon-gensym-pattern","day8.re-frame.debux.common.util/named-gensym-pattern","day8.re-frame.debux.common.util/anon-param-pattern","day8.re-frame.debux.common.util/form-tree-seq","form","cljs.core/tree-seq","cljs.core/seq","day8.re-frame.debux.common.util/with-gensyms-names","mapping","gen-name","result","name","cljs.core/contains?","cljs.core/iterate","cljs.core/inc","p1__75642#","cljs.core.map","p1__75643#","cljs.core.filter","cljs.core/first","name-for","sym-name","groups","cljs.core/re-matches","cljs.core/second","new-name","p1__75644#","cljs.core/Symbol","cljs.core/namespace","cljs.core/name","p__75650","map__75651","cljs.core/--destructure-map","cljs.core.get","day8.re-frame.debux.common.util/with-symbols-names","context","refers","aliases","state","sym","cljs.core._EQ_","cljs.core.pr_str","p1__75649#","and__4251__auto__","day8.re-frame.debux.common.util/tidy-macroexpanded-form","clojure.zip/end?","clojure.zip/root","clojure.zip/edit","cljs.core.symbol","day8.re-frame.debux.common.util/send-form!","re-frame.trace/is-trace-enabled?","new-trace__33514__auto__","cljs.core.merge","cljs.core.update","re-frame.trace/*current-trace*","cljs.core/merge","cljs.core.dissoc","day8.re-frame.debux.common.util/send-trace!","code-trace","code","cljs.core.get_in","cljs.core.conj","day8.re-frame.debux.common.util/indent-level*","cljs.core.atom","day8.re-frame.debux.common.util/reset-indent-level!","cljs.core/reset!","day8.re-frame.debux.common.util/print-seq-length*","day8.re-frame.debux.common.util/set-print-seq-length!","num","day8.re-frame.debux.common.util/cljs-env?","env","cljs.core/boolean","day8.re-frame.debux.common.util/vec->map","cljs.core.apply","cljs.core/array-map","cljs.core.mapcat","cljs.core.sequence","cljs.core/List","elm","cljs.core.keyword","day8.re-frame.debux.common.util/replace-&","clojure.walk/postwalk-replace","day8.re-frame.debux.common.util/take-n-if-seq","n","cljs.core/seq?","cljs.core.take","or__4253__auto__","cljs.core/deref","day8.re-frame.debux.common.util/truncate","s","cljs.core/count","day8.re-frame.debux.common.util/make-bars-","times","cljs.core/str","cljs.core.repeat","day8.re-frame.debux.common.util/make-bars","cljs.core/memoize","day8.re-frame.debux.common.util/prepend-bars","line","indent-level","day8.re-frame.debux.common.util/print-form-with-indent","cljs.core.println","cljs.core/flush","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","day8.re-frame.debux.common.util/form-header","p__75660","vec__75664","seq75657","G__75658","cljs.core/next","self__4851__auto__","msg","day8.re-frame.debux.common.util/prepend-blanks","lines","p1__75670#","cljs.core.mapv","day8.re-frame.debux.common.util/pprint-result-with-indent","res","sb__4795__auto__","goog.string/StringBuffer","*print-newline*-orig-val__75676","cljs.core/*print-newline*","*print-fn*-orig-val__75677","cljs.core/*print-fn*","*print-newline*-temp-val__75678","*print-fn*-temp-val__75679","x__4796__auto__","cljs.pprint.pprint","pprint","clojure.string/trim","clojure.string.split","p1__75675#","clojure.string.join","day8.re-frame.debux.common.util/insert-blank-line","day8.re-frame.debux.common.util/parse-opts","opts","acc","f","cljs.core/empty?","cljs.core/nnext","fexpr__75698","fexpr__75700","p__75701","vec__75703","day8.re-frame.debux.common.util/quote-val","day8.re-frame.debux.common.util/quote-vals","cljs.core.into","day8.re-frame.debux.common.util/include-recur?","G__75708","fexpr__75707","cljs.core.comp","cljs.core/set","cljs.core/flatten","day8.re-frame.debux.common.util/o-skip?","day8.re-frame.debux.common.util/spy-first","quoted-form","indent","js/Error","cljs.core/integer?","cljs.core.prn_str","G__75714","G__75715","day8.re-frame.debux.common.util/remove-d","day8.re-frame.debux.common.util/spy-last","G__75716","G__75717","day8.re-frame.debux.common.util/spy-comp","arg","G__75719","G__75720","day8.re-frame.debux.common.util/debux-skip-symbol?","day8.re-frame.debux.common.util/spy-first?","d-sym","node","clojure.zip/replace","cljs.core/last"],"sourcesContent":["(ns day8.re-frame.debux.common.util\n  \"Utilities common for clojure and clojurescript\"\n  (:refer-clojure :exclude [coll?])\n  (:require [clojure.string :as str]\n            [clojure.pprint :as pp]\n            [clojure.zip :as z]\n            [clojure.walk :as walk]\n            [cljs.analyzer.api :as ana]\n            [clojure.repl :as repl]\n            [re-frame.trace :as trace]))\n\n(defn map->seq[m]\n  (reduce\n    (fn [r [k v]]\n      (concat r [k v]))\n    []\n    m))\n  \n;;; zipper\n(defn sequential-zip [root]\n  (z/zipper #(or (sequential? %) (map? %)) \n            (fn [x]\n              (cond \n                (map? x)    (with-meta (map->seq x) (meta x))\n                :else       x))\n            (fn [x children]\n              (cond \n                (vector? x) (with-meta (vec children) (meta x))\n                (map? x)    (with-meta\n                              (reduce\n                                (fn [r [k v]]\n                                    (assoc r k v))\n                                  {}\n                                  (partition 2 children))\n                              (meta x))\n                :else children))\n            root))\n\n(defn right-or-next [loc]\n  (if-let [right (z/right loc)]\n    ;; in case of (... (+ a b) c) or (... a b)\n    right\n    (if (sequential? (z/node loc))\n      (let [rightmost (-> loc z/down z/rightmost)]\n        (if (sequential? (z/node rightmost))\n          ;; in case of (... (+ a (* b c)))\n          (recur rightmost)\n\n          ;; in case of (... (+ a b))\n          (-> rightmost z/next)))\n\n      ;; in case of (... a)\n      (-> loc z/next))))\n\n\n;; Tidy up macroexpansions\n\n(def auto-gensym-pattern #\"(.*)__\\d+__auto__\")              ;; form#\n(def anon-gensym-pattern #\"G__\\d+\")                         ;; (gensym)\n(def named-gensym-pattern #?(:clj #\"(.*?)\\d{4,}\"            ;; (gensym 'form), must match at least 4 numbers so we don't catch symbols with trailing numbers\n                             :cljs #\"(.*?)\\d{2,}\"))         ;; (gensym 'form), must match at least 2 numbers for cljs so we don't catch symbols with trailing numbers\n(def anon-param-pattern #\"p(\\d+)__\\d+#\")                    ;; #(%1 %2 %3)\n\n(defn form-tree-seq [form]\n  (tree-seq\n    sequential?\n    seq\n    form))\n\n(defn with-gensyms-names\n  \"Reverse gensym'd names to their original source form to make them easier to read.\"\n  [form mapping]\n  (let [gen-name (fn [result name]\n                   (if-not (contains? result (str name \"#\"))\n                     (str name \"#\")\n                     (->> (iterate inc 2)\n                          (map #(str name % \"#\"))\n                          (filter #(not (contains? result %)))\n                          (first))))\n        name-for (fn [result sym-name]\n                   (if-let [groups (re-matches auto-gensym-pattern sym-name)]\n                     (gen-name result (second groups))\n                     (if (re-matches anon-gensym-pattern sym-name)\n                       (gen-name result \"gensym\")\n                       (if-let [groups (re-matches named-gensym-pattern sym-name)]\n                         (gen-name result (second groups))\n                         (if-let [groups (re-matches anon-param-pattern sym-name)]\n                           (str \"%\" (second groups)))))))]\n    (reduce (fn [result sym-name]\n              (if (contains? result sym-name)\n                result\n                (if-let [new-name (name-for result sym-name)]\n                  (assoc result sym-name new-name)\n                  result)))\n            mapping\n            (->> (form-tree-seq form)\n                 (filter #(and (symbol? %) (nil? (namespace %))))\n                 (map name)))))\n\n(defn with-symbols-names\n  \"Tidy up fully qualified names that have aliases in the existing namespace.\"\n  ;; TODO: handle FQN's other than clojure.core\n  [form {:keys [context refers aliases] :as state} mapping]\n  (reduce (fn [result sym]\n            (if (= \"clojure.core\" (namespace sym))\n              (assoc result (pr-str sym) (name sym))\n              result))\n          mapping\n          (->> (form-tree-seq form)\n               ;; TODO: use qualified-symbol? once we are on Clojure 1.9\n               (filter #(and (symbol? %) (namespace %))))))\n\n(defn tidy-macroexpanded-form\n  \"Takes a macroexpanded form and tidies it up to be more readable by\n  unmapping gensyms and replacing fully qualified namespaces with aliases\n  or nothing if the function is referred.\"\n  [form state]\n  ;; Mapping is a mapping of String:String which represent symbols\n  (let [mapping (->> {}\n                     (with-gensyms-names form)\n                     (with-symbols-names form state))]\n    (loop [loc (sequential-zip form)]\n      (if (z/end? loc)\n        (z/root loc)\n        (if (symbol? (z/node loc))\n          (recur (z/next (z/edit loc (fn [sym] (symbol (get mapping (pr-str sym) sym))))))\n          (recur (z/next loc)))))))\n\n(defn send-form! [form]\n  (trace/merge-trace! {:tags {:form form}}))\n\n(defn send-trace! [code-trace]\n  (let [code (get-in trace/*current-trace* [:tags :code] [])]\n    ;; TODO: also capture macroexpanded form? Might be useful in some cases?\n    (trace/merge-trace!\n      {:tags {:code (conj code {:form (tidy-macroexpanded-form (:form code-trace) {}) \n                                :result (:result code-trace) \n                                :indent-level (:indent-level code-trace) \n                                :syntax-order (:syntax-order code-trace) \n                                :num-seen (:num-seen code-trace)})}})))\n\n;;; For internal debugging\n(defmacro d\n  \"The internal macro to debug dbg macro.\n   <form any> a form to be evaluated\"\n  [form]\n  `(let [return# ~form]\n     (println \">> dbg_:\" (pr-str '~form) \"=>\\n\" (pr-str return#) \"<<\")\n     return#))\n\n\n;;; indent-level control\n(def indent-level* (atom 1))\n\n(defn reset-indent-level! []\n  (reset! indent-level* 1))\n\n\n;;; print-seq-length\n(def print-seq-length* (atom 100))\n\n(defn set-print-seq-length! [num]\n  (reset! print-seq-length* num))\n\n\n;;; general\n(defmacro read-source [sym]\n  `(-> (repl/source ~sym)\n       with-out-str\n       read-string))\n\n(defn cljs-env? [env]\n  (boolean (:ns env)))\n\n(defn vec->map\n  \"Transsub-forms a vector into an array-map with key/value pairs.\n  (def a 10)\n  (def b 20)\n  (vec-map [a b :c [30 40]])\n  => {:a 10 :b 20 ::c :c :[30 40] [30 40]}\"\n  [v]\n  (apply array-map\n         (mapcat (fn [elm]\n                   `[~(keyword (str elm)) ~elm])\n                 v)))\n\n(defn replace-& [v]\n  (walk/postwalk-replace {'& ''&} v))\n\n\n\n;;; symbol with namespace\n#?(:clj\n   (defn- var->symbol [v]\n     (let [m    (meta v)\n           ns   (str (ns-name (:ns m)))\n           name (str (:name m))]\n       (symbol ns name))))\n\n#?(:clj\n   (defn- ns-symbol-for-clj [sym]\n     (if-let [v (resolve sym)]\n       (var->symbol v)\n       sym)))\n\n#?(:clj\n   (defn- ns-symbol-for-cljs [sym env]\n     (if-let [meta (ana/resolve env sym)]\n       ;; normal symbol\n       (let [[ns name] (str/split (str (:name meta)) #\"/\")]\n         ;; The special symbol `.` must be handled in the following special symbol part.\n         ;; However, the special symbol `.` returns meta {:name / :ns nil}, which may be a bug.\n         (if (nil? ns)\n           sym\n           (symbol ns name)))\n       ;; special symbols except for `.`\n       sym)))\n\n#?(:clj\n   (defn ns-symbol [sym & [env]]\n     (if (symbol? sym)\n       (if (cljs-env? env)\n         (ns-symbol-for-cljs sym env)\n         (ns-symbol-for-clj sym))\n       sym)))\n\n\n;;; print\n(defn take-n-if-seq [n result]\n  (if (seq? result)\n    (take (or n @print-seq-length*) result)\n    result))\n\n(defn truncate [s]\n  (if (> (count s) 70)\n    (str (.substring s 0 70) \" ...\")\n    s))\n\n(defn- make-bars-\n  [times]\n  (apply str (repeat times \"|\")))\n\n(def make-bars (memoize make-bars-))\n\n(defn prepend-bars\n  [line indent-level]\n  (str (make-bars indent-level) \" \" line))\n\n(defn print-form-with-indent\n  [form indent-level]\n  ;; TODO: trace this information somehow\n  (println (prepend-bars form indent-level))\n  (flush))\n\n(defn form-header [form & [msg]]\n  (str (truncate (pr-str form))\n       (and msg (str \"   <\" msg \">\"))\n       \" =>\"))\n\n\n(defn prepend-blanks\n  [lines]\n  (mapv #(str \"  \" %) lines))\n\n(defn pprint-result-with-indent\n  [result indent-level]\n  ;; TODO: trace this information somehow\n  (let [res    result\n        result (with-out-str (pp/pprint res))\n        pprint (str/trim result)]\n    (println (->> (str/split pprint #\"\\n\")\n                  prepend-blanks\n                  (mapv #(prepend-bars % indent-level))\n                  (str/join \"\\n\")))\n    (flush)))\n\n(defn insert-blank-line []\n  (println \" \")\n  (flush))\n\n\n;;; parse options\n(defn parse-opts\n  [opts]\n  (loop [opts opts\n         acc  {}]\n    (let [f (first opts)\n          s (second opts)]\n      (cond\n        (empty? opts)\n        acc\n\n        (number? f)\n        (recur (next opts) (assoc acc :n f))\n\n        (string? f)\n        (recur (next opts) (assoc acc :msg f))\n\n        (= f :if)\n        (recur (nnext opts) (assoc acc :condition s))\n\n        ;;; for clojurescript\n        (= f :js)\n        (recur (next opts) (assoc acc :js true))\n\n        (#{:once :o} f)\n        (recur (next opts) (assoc acc :once true))\n\n        (#{:style :s} f)\n        (recur (nnext opts) (assoc acc :style s))\n\n        (= f :clog)\n        (recur (next opts) (assoc acc :clog true))))))\n\n\n;;; quote the value parts of a map\n(defn quote-val [[k v]]\n  `[~k '~v])\n\n(defn quote-vals [m]\n  (->> (map quote-val m)\n       (into {})))\n\n\n;;; for recur processing\n(defn include-recur? [form]\n  (((comp set flatten) form) 'recur))\n\n#?(:clj\n   (defn final-target? [sym targets env]\n     (let [ns-sym (ns-symbol sym env)]\n       (or (get targets ns-sym)\n           (some #(= % ns-sym)\n                 '[clojure.core/defn clojure.core/defn- clojure.core/fn\n                   cljs.core/defn cljs.core/defn- cljs.core/fn])))))\n\n(defn o-skip? [sym]\n  (= 'debux.common.macro-specs/o-skip sym))\n\n(declare remove-d)\n\n;;; spy functions\n(def spy-first\n  (fn [result quoted-form indent]\n    (assert (integer? indent) (str \"indent was not correctly replaced for form \" (prn-str quoted-form) \"\\nThis is a bug, please report it to https://github.com/Day8/re-frame-debux\"))\n    (send-trace! {:form (remove-d quoted-form 'dummy) :result result :indent-level indent})\n    ;(print-form-with-indent (form-header quoted-form) indent)\n    ;(pprint-result-with-indent (take-n-if-seq 100 result) indent)\n    result))\n\n(def spy-last\n  (fn [quoted-form indent result]\n    (assert (integer? indent) (str \"indent was not correctly replaced for form \" (prn-str quoted-form) \"\\nThis is a bug, please report it to https://github.com/Day8/re-frame-debux\"))\n    (send-trace! {:form (remove-d quoted-form 'dummy) :result result :indent-level indent})\n    ;(print-form-with-indent (form-header quoted-form) indent)\n    ;(pprint-result-with-indent (take-n-if-seq 100 result) indent)\n    result))\n\n(defn spy-comp [quoted-form indent form]\n  (fn [& arg]\n    (let [result (apply form arg)]\n      (assert (integer? indent) (str \"indent was not correctly replaced for form \" (prn-str quoted-form) \"\\nThis is a bug, please report it to https://github.com/Day8/re-frame-debux\"))\n      (send-trace! {:form (remove-d quoted-form 'dummy) :result result :indent-level indent})\n      ;(print-form-with-indent (form-header quoted-form) indent)\n      ;(pprint-result-with-indent (take-n-if-seq 100 result) indent)\n      result)))\n\n;; Remove trace info\n\n(defn debux-skip-symbol? [sym]\n  (contains? #{'day8.re-frame.debux.common.macro-specs/skip-outer\n               'day8.re-frame.debux.common.macro-specs/skip\n               'day8.re-frame.debux.common.macro-specs/o-skip\n               :day8.re-frame.debux.common.macro-specs/skip-place}\n             sym))\n\n(defn spy-first? [sym]\n  (= 'day8.re-frame.debux.common.util/spy-first sym))\n\n(defn remove-d [form d-sym]\n  ;; TODO: should we instead look to rewrite the quoted/spied forms\n  ;; at macro compile time, rather than filtering them out\n  ;; when the trace is being emitted?\n  (loop [loc (sequential-zip form)]\n    (let [node (z/node loc)]\n      ;(ut/d node)\n      (cond\n        (z/end? loc) (z/root loc)\n\n        ;; in case of (d ...)\n        (and (seq? node)\n             (or (= d-sym (first node))\n                 (debux-skip-symbol? (first node))\n                 (spy-first? (first node))))\n        ;; We take the third node, because the first two are\n        ;; (d <indent-level> ...)\n        (recur (z/replace loc (last node)))\n\n        ;; in case of spy-last\n        (and (seq? node)\n             (= `spy-last (first node)))\n        (recur (z/replace loc (last node)))\n\n        :else\n        (recur (z/next loc))))))\n"]}