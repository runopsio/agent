shadow$provide.module$node_modules$$codemirror$rangeset$dist$index_cjs=function(global,require,module,exports){function cmpRange(a,b){return a.from-b.from||a.value.startSide-b.value.startSide}function lazySort(ranges){if(1<ranges.length)for(let prev=ranges[0],i=1;i<ranges.length;i++){let cur=ranges[i];if(0<cmpRange(prev,cur))return ranges.slice().sort(cmpRange);prev=cur}return ranges}function findSharedChunks(a,b,textDiff){let inA=new Map;for(var set$jscomp$0 of a)for(a=0;a<set$jscomp$0.chunk.length;a++)0>=
set$jscomp$0.chunk[a].maxPoint&&inA.set(set$jscomp$0.chunk[a],set$jscomp$0.chunkPos[a]);set$jscomp$0=new Set;for(let set of b)for(b=0;b<set.chunk.length;b++)a=inA.get(set.chunk[b]),null==a||(textDiff?textDiff.mapPos(a):a)!=set.chunkPos[b]||(null===textDiff||void 0===textDiff?0:textDiff.touchesRange(a,a+set.chunk[b].length))||set$jscomp$0.add(set.chunk[b]);return set$jscomp$0}function heapBubble(heap,index){for(let cur=heap[index];;){let childIndex=(index<<1)+1;if(childIndex>=heap.length)break;let child=
heap[childIndex];childIndex+1<heap.length&&0<=child.compare(heap[childIndex+1])&&(child=heap[childIndex+1],childIndex++);if(0>cur.compare(child))break;heap[childIndex]=cur;heap[index]=child;index=childIndex}}function compare(a,startA,b,startB,length,comparator){a.goto(startA);b.goto(startB);length=startB+length;let pos=startB;for(startA=startB-startA;;){startB=a.to+startA-b.to||a.endSide-b.endSide;let end=0>startB?a.to+startA:b.to,clipEnd=Math.min(end,length);a.point||b.point?a.point&&b.point&&(a.point==
b.point||a.point.eq(b.point))&&sameValues(a.activeForPoint(a.to+startA),b.activeForPoint(b.to))||comparator.comparePoint(pos,clipEnd,a.point,b.point):clipEnd>pos&&!sameValues(a.active,b.active)&&comparator.compareRange(pos,clipEnd,a.active,b.active);if(end>length)break;pos=end;0>=startB&&a.next();0<=startB&&b.next()}}function sameValues(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!=b[i]&&!a[i].eq(b[i]))return!1;return!0}function remove(array,index){for(let i=index,e=array.length-
1;i<e;i++)array[i]=array[i+1];array.pop()}function insert(array,index,value){for(let i=array.length-1;i>=index;i--)array[i+1]=array[i];array[index]=value}function findMinIndex(value,array){let found=-1,foundPos=1E9;for(let i=0;i<array.length;i++)0>(array[i]-foundPos||value[i].endSide-value[found].endSide)&&(found=i,foundPos=array[i]);return found}Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$codemirror$state$dist$index_cjs");class RangeValue{eq(other){return this==
other}range(from,to=from){return new Range(from,to,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0;RangeValue.prototype.point=!1;RangeValue.prototype.mapMode=global.MapMode.TrackDel;class Range{constructor(from,to,value){this.from=from;this.to=to;this.value=value}}class Chunk{constructor(from,to,value,maxPoint){this.from=from;this.to=to;this.value=value;this.maxPoint=maxPoint}get length(){return this.to[this.to.length-1]}findIndex(pos,side,end,startAt=0){let arr=end?this.to:this.from;
for(let lo=startAt,hi=arr.length;;){if(lo==hi)return lo;startAt=lo+hi>>1;let diff=arr[startAt]-pos||(end?this.value[startAt].endSide:this.value[startAt].startSide)-side;if(startAt==lo)return 0<=diff?lo:hi;0<=diff?hi=startAt:lo=startAt+1}}between(offset,from,to,f){for(let i=this.findIndex(from,-1E9,!0),e=this.findIndex(to,1E9,!1,i);i<e;i++)if(!1===f(this.from[i]+offset,this.to[i]+offset,this.value[i]))return!1}map(offset,changes){let value=[],from=[],to=[],newPos=-1,maxPoint=-1;for(let i=0;i<this.value.length;i++){let val=
this.value[i],curFrom=this.from[i]+offset;var curTo=this.to[i]+offset,newFrom=void 0;if(curFrom==curTo){newFrom=changes.mapPos(curFrom,val.startSide,val.mapMode);if(null==newFrom)continue;newFrom=curTo=newFrom;if(val.startSide!=val.endSide&&(curTo=changes.mapPos(curFrom,val.endSide),curTo<newFrom))continue}else if(newFrom=changes.mapPos(curFrom,val.startSide),curTo=changes.mapPos(curTo,val.endSide),newFrom>curTo||newFrom==curTo&&0<val.startSide&&0>=val.endSide)continue;0>(curTo-newFrom||val.endSide-
val.startSide)||(0>newPos&&(newPos=newFrom),val.point&&(maxPoint=Math.max(maxPoint,curTo-newFrom)),value.push(val),from.push(newFrom-newPos),to.push(curTo-newPos))}return{mapped:value.length?new Chunk(from,to,value,maxPoint):null,pos:newPos}}}class RangeSet{constructor(chunkPos,chunk,nextLayer=RangeSet.empty,maxPoint){this.chunkPos=chunkPos;this.chunk=chunk;this.nextLayer=nextLayer;this.maxPoint=maxPoint}get length(){let last=this.chunk.length-1;return 0>last?0:Math.max(this.chunkEnd(last),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;
let size=this.nextLayer.size;for(let chunk of this.chunk)size+=chunk.value.length;return size}chunkEnd(index){return this.chunkPos[index]+this.chunk[index].length}update(updateSpec){let {add=[],sort=!1,filterFrom=0,filterTo=this.length}=updateSpec;updateSpec=updateSpec.filter;if(0==add.length&&!updateSpec)return this;sort&&add.slice().sort(cmpRange);if(this.isEmpty)return add.length?RangeSet.of(add):this;let cur=(new LayerCursor(this,null,-1)).goto(0),i=0,spill=[],builder=new RangeSetBuilder;for(;cur.value||
i<add.length;)if(i<add.length&&0<=(cur.from-add[i].from||cur.startSide-add[i].value.startSide)){let range=add[i++];builder.addInner(range.from,range.to,range.value)||spill.push(range)}else if(1==cur.rangeIndex&&cur.chunkIndex<this.chunk.length&&(i==add.length||this.chunkEnd(cur.chunkIndex)<add[i].from)&&(!updateSpec||filterFrom>this.chunkEnd(cur.chunkIndex)||filterTo<this.chunkPos[cur.chunkIndex])&&builder.addChunk(this.chunkPos[cur.chunkIndex],this.chunk[cur.chunkIndex]))cur.nextChunk();else{if(!updateSpec||
filterFrom>cur.to||filterTo<cur.from||updateSpec(cur.from,cur.to,cur.value))builder.addInner(cur.from,cur.to,cur.value)||spill.push(new Range(cur.from,cur.to,cur.value));cur.next()}return builder.finishInner(this.nextLayer.isEmpty&&!spill.length?RangeSet.empty:this.nextLayer.update({add:spill,filter:updateSpec,filterFrom,filterTo}))}map(changes){if(0==changes.length||this.isEmpty)return this;let chunks=[],chunkPos=[],maxPoint=-1;for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=
this.chunk[i],touch=changes.touchesRange(start,start+chunk.length);if(!1===touch)maxPoint=Math.max(maxPoint,chunk.maxPoint),chunks.push(chunk),chunkPos.push(changes.mapPos(start));else if(!0===touch){let {mapped,pos}=chunk.map(start,changes);mapped&&(maxPoint=Math.max(maxPoint,mapped.maxPoint),chunks.push(mapped),chunkPos.push(pos))}}changes=this.nextLayer.map(changes);return 0==chunks.length?changes:new RangeSet(chunkPos,chunks,changes,maxPoint)}between(from,to,f){if(!this.isEmpty){for(let i=0;i<
this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i];if(to>=start&&from<=start+chunk.length&&!1===chunk.between(start,from-start,to-start,f))return}this.nextLayer.between(from,to,f)}}iter(from=0){return HeapCursor.from([this]).goto(from)}get isEmpty(){return this.nextLayer==this}static iter(sets,from=0){return HeapCursor.from(sets).goto(from)}static compare(oldSets,newSets,textDiff,comparator,minPointSize=-1){oldSets=oldSets.filter(set=>0<set.maxPoint||!set.isEmpty&&set.maxPoint>=
minPointSize);newSets=newSets.filter(set=>0<set.maxPoint||!set.isEmpty&&set.maxPoint>=minPointSize);let sharedChunks=findSharedChunks(oldSets,newSets,textDiff),sideA=new SpanCursor(oldSets,sharedChunks,minPointSize),sideB=new SpanCursor(newSets,sharedChunks,minPointSize);textDiff.iterGaps((fromA,fromB,length)=>compare(sideA,fromA,sideB,fromB,length,comparator));textDiff.empty&&0==textDiff.length&&compare(sideA,0,sideB,0,0,comparator)}static eq(oldSets,newSets,from=0,to){null==to&&(to=1E9);var a=oldSets.filter(set=>
!set.isEmpty&&0>newSets.indexOf(set));let b=newSets.filter(set=>!set.isEmpty&&0>oldSets.indexOf(set));if(a.length!=b.length)return!1;if(!a.length)return!0;let sharedChunks=findSharedChunks(a,b);a=(new SpanCursor(a,sharedChunks,0)).goto(from);for(from=(new SpanCursor(b,sharedChunks,0)).goto(from);;){if(a.to!=from.to||!sameValues(a.active,from.active)||a.point&&(!from.point||!a.point.eq(from.point)))return!1;if(a.to>to)return!0;a.next();from.next()}}static spans(sets,from,to,iterator,minPointSize=-1){var _a;
sets=(new SpanCursor(sets,null,minPointSize,null===(_a=iterator.filterPoint)||void 0===_a?void 0:_a.bind(iterator))).goto(from);for(_a=sets.openStart;;){minPointSize=Math.min(sets.to,to);sets.point?(iterator.point(from,minPointSize,sets.point,sets.activeForPoint(sets.to),_a),_a=sets.openEnd(minPointSize)+(sets.to>minPointSize?1:0)):minPointSize>from&&(iterator.span(from,minPointSize,sets.active,_a),_a=sets.openEnd(minPointSize));if(sets.to>to)break;from=sets.to;sets.next()}return _a}static of(ranges,
sort=!1){let build=new RangeSetBuilder;for(let range of ranges instanceof Range?[ranges]:sort?lazySort(ranges):ranges)build.add(range.from,range.to,range.value);return build.finish()}}RangeSet.empty=new RangeSet([],[],null,-1);RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=[];this.chunkPos=[];this.chunkStart=-1;this.last=null;this.lastTo=this.lastFrom=-1E9;this.from=[];this.to=[];this.value=[];this.setMaxPoint=this.maxPoint=-1;this.nextLayer=null}finishChunk(newArrays){this.chunks.push(new Chunk(this.from,
this.to,this.value,this.maxPoint));this.chunkPos.push(this.chunkStart);this.chunkStart=-1;this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint);this.maxPoint=-1;newArrays&&(this.from=[],this.to=[],this.value=[])}add(from,to,value){this.addInner(from,to,value)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(from,to,value)}addInner(from,to,value){let diff=from-this.lastTo||value.startSide-this.last.endSide;if(0>=diff&&0>(from-this.lastFrom||value.startSide-this.last.startSide))throw Error("Ranges must be added sorted by `from` position and `startSide`");
if(0>diff)return!1;250==this.from.length&&this.finishChunk(!0);0>this.chunkStart&&(this.chunkStart=from);this.from.push(from-this.chunkStart);this.to.push(to-this.chunkStart);this.last=value;this.lastFrom=from;this.lastTo=to;this.value.push(value);value.point&&(this.maxPoint=Math.max(this.maxPoint,to-from));return!0}addChunk(from,chunk){if(0>(from-this.lastTo||chunk.value[0].startSide-this.last.endSide))return!1;this.from.length&&this.finishChunk(!0);this.setMaxPoint=Math.max(this.setMaxPoint,chunk.maxPoint);
this.chunks.push(chunk);this.chunkPos.push(from);let last=chunk.value.length-1;this.last=chunk.value[last];this.lastFrom=chunk.from[last]+from;this.lastTo=chunk.to[last]+from;return!0}finish(){return this.finishInner(RangeSet.empty)}finishInner(next){this.from.length&&this.finishChunk(!1);if(0==this.chunks.length)return next;next=new RangeSet(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(next):next,this.setMaxPoint);this.from=null;return next}}class LayerCursor{constructor(layer,
skip,minPoint,rank=0){this.layer=layer;this.skip=skip;this.minPoint=minPoint;this.rank=rank}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(pos,side=-1E9){this.chunkIndex=this.rangeIndex=0;this.gotoInner(pos,side,!1);return this}gotoInner(pos,side,forward){for(;this.chunkIndex<this.layer.chunk.length;){let next=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(next)||this.layer.chunkEnd(this.chunkIndex)<pos||next.maxPoint<
this.minPoint))break;this.chunkIndex++;forward=!1}this.chunkIndex<this.layer.chunk.length&&(pos=this.layer.chunk[this.chunkIndex].findIndex(pos-this.layer.chunkPos[this.chunkIndex],side,!0),(!forward||this.rangeIndex<pos)&&this.setRangeIndex(pos));this.next()}forward(pos,side){0>(this.to-pos||this.endSide-side)&&this.gotoInner(pos,side,!0)}next(){for(;;)if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1E9;this.value=null;break}else{let chunkPos=this.layer.chunkPos[this.chunkIndex],chunk=
this.layer.chunk[this.chunkIndex];this.from=chunkPos+chunk.from[this.rangeIndex];this.to=chunkPos+chunk.to[this.rangeIndex];this.value=chunk.value[this.rangeIndex];this.setRangeIndex(this.rangeIndex+1);if(0>this.minPoint||this.value.point&&this.to-this.from>=this.minPoint)break}}setRangeIndex(index){if(index==this.layer.chunk[this.chunkIndex].value.length){this.chunkIndex++;if(this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;
this.rangeIndex=0}else this.rangeIndex=index}nextChunk(){this.chunkIndex++;this.rangeIndex=0;this.next()}compare(other){return this.from-other.from||this.startSide-other.startSide||this.to-other.to||this.endSide-other.endSide}}class HeapCursor{constructor(heap){this.heap=heap}static from(sets,skip=null,minPoint=-1){let heap=[];for(let i=0;i<sets.length;i++)for(let cur=sets[i];!cur.isEmpty;cur=cur.nextLayer)cur.maxPoint>=minPoint&&heap.push(new LayerCursor(cur,skip,minPoint,i));return 1==heap.length?
heap[0]:new HeapCursor(heap)}get startSide(){return this.value?this.value.startSide:0}goto(pos,side=-1E9){for(let cur of this.heap)cur.goto(pos,side);for(pos=this.heap.length>>1;0<=pos;pos--)heapBubble(this.heap,pos);this.next();return this}forward(pos,side){for(var cur of this.heap)cur.forward(pos,side);for(cur=this.heap.length>>1;0<=cur;cur--)heapBubble(this.heap,cur);0>(this.to-pos||this.value.endSide-side)&&this.next()}next(){if(0==this.heap.length)this.from=this.to=1E9,this.value=null,this.rank=
-1;else{let top=this.heap[0];this.from=top.from;this.to=top.to;this.value=top.value;this.rank=top.rank;top.value&&top.next();heapBubble(this.heap,0)}}}class SpanCursor{constructor(sets,skip,minPoint,filterPoint=()=>!0){this.minPoint=minPoint;this.filterPoint=filterPoint;this.active=[];this.activeTo=[];this.activeRank=[];this.minActive=-1;this.point=null;this.pointRank=this.pointFrom=0;this.to=-1E9;this.endSide=0;this.openStart=-1;this.cursor=HeapCursor.from(sets,skip,minPoint)}goto(pos,side=-1E9){this.cursor.goto(pos,
side);this.active.length=this.activeTo.length=this.activeRank.length=0;this.minActive=-1;this.to=pos;this.endSide=side;this.openStart=-1;this.next();return this}forward(pos,side){for(;-1<this.minActive&&0>(this.activeTo[this.minActive]-pos||this.active[this.minActive].endSide-side);)this.removeActive(this.minActive);this.cursor.forward(pos,side)}removeActive(index){remove(this.active,index);remove(this.activeTo,index);remove(this.activeRank,index);this.minActive=findMinIndex(this.active,this.activeTo)}addActive(trackOpen){let i=
0,{value,to,rank}=this.cursor;for(;i<this.activeRank.length&&this.activeRank[i]<=rank;)i++;insert(this.active,i,value);insert(this.activeTo,i,to);insert(this.activeRank,i,rank);trackOpen&&insert(trackOpen,i,this.cursor.from);this.minActive=findMinIndex(this.active,this.activeTo)}next(){let from=this.to;var wasPoint=this.point;this.point=null;let trackOpen=0>this.openStart?[]:null,trackExtra=0;for(;;){var a=this.minActive;if(-1<a&&0>(this.activeTo[a]-this.cursor.from||this.active[a].endSide-this.cursor.startSide)){if(this.activeTo[a]>
from){this.to=this.activeTo[a];this.endSide=this.active[a].endSide;break}this.removeActive(a);trackOpen&&remove(trackOpen,a)}else if(this.cursor.value)if(this.cursor.from>from){this.to=this.cursor.from;this.endSide=this.cursor.startSide;break}else if(a=this.cursor.value,a.point)if(wasPoint&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)this.cursor.next();else if(this.filterPoint(this.cursor.from,this.cursor.to,this.cursor.value,this.cursor.rank)){this.point=a;this.pointFrom=this.cursor.from;
this.pointRank=this.cursor.rank;this.to=this.cursor.to;this.endSide=a.endSide;this.cursor.from<from&&(trackExtra=1);this.cursor.next();this.to>from&&this.forward(this.to,this.endSide);break}else this.cursor.next();else this.addActive(trackOpen),this.cursor.next();else{this.to=this.endSide=1E9;break}}if(trackOpen){for(wasPoint=0;wasPoint<trackOpen.length&&trackOpen[wasPoint]<from;)wasPoint++;this.openStart=wasPoint+trackExtra}}activeForPoint(to){if(!this.active.length)return this.active;let active=
[];for(let i=this.active.length-1;0<=i&&!(this.activeRank[i]<this.pointRank);i--)(this.activeTo[i]>to||this.activeTo[i]==to&&this.active[i].endSide>=this.point.endSide)&&active.push(this.active[i]);return active.reverse()}openEnd(to){let open=0;for(let i=this.activeTo.length-1;0<=i&&this.activeTo[i]>to;i--)open++;return open}}exports.Range=Range;exports.RangeSet=RangeSet;exports.RangeSetBuilder=RangeSetBuilder;exports.RangeValue=RangeValue}
//# sourceMappingURL=module$node_modules$$codemirror$rangeset$dist$index_cjs.js.map
