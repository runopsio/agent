{
"version":3,
"file":"module$node_modules$$sentry$utils$dist$promisebuffer.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/@sentry/utils/dist/promisebuffer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$sentry$utils$dist$promisebuffer\"] = function(global,require,module,exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar error_1 = require(\"./error\");\nvar syncpromise_1 = require(\"./syncpromise\");\n/** A simple queue that holds promises. */\nvar PromiseBuffer = /** @class */ (function () {\n    function PromiseBuffer(_limit) {\n        this._limit = _limit;\n        /** Internal set of queued Promises */\n        this._buffer = [];\n    }\n    /**\n     * Says if the buffer is ready to take more requests\n     */\n    PromiseBuffer.prototype.isReady = function () {\n        return this._limit === undefined || this.length() < this._limit;\n    };\n    /**\n     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n     *\n     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n     *        limit check.\n     * @returns The original promise.\n     */\n    PromiseBuffer.prototype.add = function (taskProducer) {\n        var _this = this;\n        if (!this.isReady()) {\n            return syncpromise_1.SyncPromise.reject(new error_1.SentryError('Not adding Promise due to buffer limit reached.'));\n        }\n        // start the task and add its promise to the queue\n        var task = taskProducer();\n        if (this._buffer.indexOf(task) === -1) {\n            this._buffer.push(task);\n        }\n        void task\n            .then(function () { return _this.remove(task); })\n            // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n            // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n            // have promises, so TS has to polyfill when down-compiling.)\n            .then(null, function () {\n            return _this.remove(task).then(null, function () {\n                // We have to add another catch here because `this.remove()` starts a new promise chain.\n            });\n        });\n        return task;\n    };\n    /**\n     * Remove a promise from the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    PromiseBuffer.prototype.remove = function (task) {\n        var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];\n        return removedTask;\n    };\n    /**\n     * This function returns the number of unresolved promises in the queue.\n     */\n    PromiseBuffer.prototype.length = function () {\n        return this._buffer.length;\n    };\n    /**\n     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n     * `false` otherwise\n     */\n    PromiseBuffer.prototype.drain = function (timeout) {\n        var _this = this;\n        return new syncpromise_1.SyncPromise(function (resolve) {\n            // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n            var capturedSetTimeout = setTimeout(function () {\n                if (timeout && timeout > 0) {\n                    resolve(false);\n                }\n            }, timeout);\n            // if all promises resolve in time, cancel the timer and resolve to `true`\n            void syncpromise_1.SyncPromise.all(_this._buffer)\n                .then(function () {\n                clearTimeout(capturedSetTimeout);\n                resolve(true);\n            })\n                .then(null, function () {\n                resolve(true);\n            });\n        });\n    };\n    return PromiseBuffer;\n}());\nexports.PromiseBuffer = PromiseBuffer;\n//# sourceMappingURL=promisebuffer.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","error_1","syncpromise_1","PromiseBuffer","_limit","_buffer","prototype","isReady","PromiseBuffer.prototype.isReady","undefined","length","add","PromiseBuffer.prototype.add","taskProducer","_this","SyncPromise","reject","SentryError","task","indexOf","push","then","remove","PromiseBuffer.prototype.remove","splice","removedTask","PromiseBuffer.prototype.length","drain","PromiseBuffer.prototype.drain","timeout","resolve","capturedSetTimeout","setTimeout","all","clearTimeout"]
}
