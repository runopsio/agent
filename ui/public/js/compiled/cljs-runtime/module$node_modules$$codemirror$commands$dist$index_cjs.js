shadow$provide.module$node_modules$$codemirror$commands$dist$index_cjs=function(global,require,module,exports){function updateSel(sel,by){return state$jscomp$0.EditorSelection.create(sel.ranges.map(by),sel.mainIndex)}function setSel(state,selection){return state.update({selection,scrollIntoView:!0,userEvent:"select"})}function moveSel({state,dispatch},how){how=updateSel(state.selection,how);if(how.eq(state.selection))return!1;dispatch(setSel(state,how));return!0}function rangeEnd(range,forward){return state$jscomp$0.EditorSelection.cursor(forward?
range.to:range.from)}function cursorByChar(view,forward){return moveSel(view,range=>range.empty?view.moveByChar(range,forward):rangeEnd(range,forward))}function cursorByGroup(view,forward){return moveSel(view,range=>range.empty?view.moveByGroup(range,forward):rangeEnd(range,forward))}function moveBySubword(view,range,forward){let categorize=view.state.charCategorizer(range.from);return view.moveByChar(range,forward,start=>{let cat=state$jscomp$0.CharCategory.Space,pos=range.from,done=!1,sawUpper=
!1,sawLower=!1,step=next=>{if(done)return!1;pos+=forward?next.length:-next.length;let nextCat=categorize(next),ahead;cat==state$jscomp$0.CharCategory.Space&&(cat=nextCat);if(cat!=nextCat)return!1;if(cat==state$jscomp$0.CharCategory.Word)if(next.toLowerCase()==next){if(!forward&&sawUpper)return!1;sawLower=!0}else if(sawLower){if(forward)return!1;done=!0}else{if(sawUpper&&forward&&categorize(ahead=view.state.sliceDoc(pos,pos+1))==state$jscomp$0.CharCategory.Word&&ahead.toLowerCase()==ahead)return!1;
sawUpper=!0}return!0};step(start);return step})}function cursorBySubword(view,forward){return moveSel(view,range=>range.empty?moveBySubword(view,range,forward):rangeEnd(range,forward))}function moveBySyntax(state$1,start,forward){let pos=language.syntaxTree(state$1).resolveInner(start.head),bracketProp=forward?common.NodeProp.closedBy:common.NodeProp.openedBy;for(start=start.head;;){let next=forward?pos.childAfter(start):pos.childBefore(start);if(!next)break;a:{var JSCompiler_inline_result=state$1;
var node=next;if(node.type.prop(bracketProp)){JSCompiler_inline_result=!0;break a}let len=node.to-node.from;JSCompiler_inline_result=len&&(2<len||/[^\s,.;:]/.test(JSCompiler_inline_result.sliceDoc(node.from,node.to)))||node.firstChild}JSCompiler_inline_result?pos=next:start=forward?next.to:next.from}let match;state$1=pos.type.prop(bracketProp)&&(match=forward?matchbrackets.matchBrackets(state$1,pos.from,1):matchbrackets.matchBrackets(state$1,pos.to,-1))&&match.matched?forward?match.end.to:match.end.from:
forward?pos.to:pos.from;return state$jscomp$0.EditorSelection.cursor(state$1,forward?-1:1)}function cursorByLine(view,forward){return moveSel(view,range=>{if(!range.empty)return rangeEnd(range,forward);let moved=view.moveVertically(range,forward);return moved.head!=range.head?moved:view.moveToLineBoundary(range,forward)})}function cursorByPage(view$1,forward){let {state}=view$1,selection=updateSel(state.selection,range=>range.empty?view$1.moveVertically(range,forward,view$1.dom.clientHeight):rangeEnd(range,
forward));if(selection.eq(state.selection))return!1;let startPos=view$1.coordsAtPos(state.selection.main.head),scrollRect=view$1.scrollDOM.getBoundingClientRect();view$1.dispatch(setSel(state,selection),{effects:startPos&&startPos.top>scrollRect.top&&startPos.bottom<scrollRect.bottom?view$jscomp$0.EditorView.scrollIntoView(selection.main.head,{y:"start",yMargin:startPos.top-scrollRect.top}):void 0});return!0}function moveByLineBoundary(view,start,forward){let line=view.lineBlockAt(start.head),moved=
view.moveToLineBoundary(start,forward);moved.head==start.head&&moved.head!=(forward?line.to:line.from)&&(moved=view.moveToLineBoundary(start,forward,!1));!forward&&moved.head==line.from&&line.length&&(view=/^\s*/.exec(view.state.sliceDoc(line.from,Math.min(line.from+100,line.to)))[0].length)&&start.head!=line.from+view&&(moved=state$jscomp$0.EditorSelection.cursor(line.from+view));return moved}function toMatchingBracket(state$1,dispatch,extend){let found=!1,selection=updateSel(state$1.selection,range=>
{var matching=matchbrackets.matchBrackets(state$1,range.head,-1)||matchbrackets.matchBrackets(state$1,range.head,1)||0<range.head&&matchbrackets.matchBrackets(state$1,range.head-1,1)||range.head<state$1.doc.length&&matchbrackets.matchBrackets(state$1,range.head+1,-1);if(!matching||!matching.end)return range;found=!0;matching=matching.start.from==range.head?matching.end.to:matching.end.from;return extend?state$jscomp$0.EditorSelection.range(range.anchor,matching):state$jscomp$0.EditorSelection.cursor(matching)});
if(!found)return!1;dispatch(setSel(state$1,selection));return!0}function extendSel(view,how){let selection=updateSel(view.state.selection,range=>{let head=how(range);return state$jscomp$0.EditorSelection.range(range.anchor,head.head,head.goalColumn)});if(selection.eq(view.state.selection))return!1;view.dispatch(setSel(view.state,selection));return!0}function selectByChar(view,forward){return extendSel(view,range=>view.moveByChar(range,forward))}function selectByGroup(view,forward){return extendSel(view,
range=>view.moveByGroup(range,forward))}function selectBySubword(view,forward){return extendSel(view,range=>moveBySubword(view,range,forward))}function selectByLine(view,forward){return extendSel(view,range=>view.moveVertically(range,forward))}function selectByPage(view,forward){return extendSel(view,range=>view.moveVertically(range,forward,view.dom.clientHeight))}function deleteBy({state:state$1,dispatch},by){if(state$1.readOnly)return!1;let event="delete.selection",changes=state$1.changeByRange(range=>
{let {from,to}=range;if(from==to){let towards=by(from);towards<from?event="delete.backward":towards>from&&(event="delete.forward");from=Math.min(from,towards);to=Math.max(to,towards)}return from==to?{range}:{changes:{from,to},range:state$jscomp$0.EditorSelection.cursor(from)}});if(changes.changes.empty)return!1;dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:event}));return!0}function skipAtomic(target,pos,forward){if(target instanceof view$jscomp$0.EditorView)for(let ranges of target.pluginField(view$jscomp$0.PluginField.atomicRanges))ranges.between(pos,
pos,(from,to)=>{from<pos&&to>pos&&(pos=forward?to:from)});return pos}function selectedLineBlocks(state){let blocks=[];var upto=-1;for(let range of state.selection.ranges){let startLine=state.doc.lineAt(range.from),endLine=state.doc.lineAt(range.to);range.empty||range.to!=endLine.from||(endLine=state.doc.lineAt(range.to-1));upto>=startLine.number?(upto=blocks[blocks.length-1],upto.to=endLine.to,upto.ranges.push(range)):blocks.push({from:startLine.from,to:endLine.to,ranges:[range]});upto=endLine.number+
1}return blocks}function moveLine(state$1,dispatch,forward){if(state$1.readOnly)return!1;let changes=[],ranges=[];for(let block of selectedLineBlocks(state$1)){if(forward?block.to==state$1.doc.length:0==block.from)continue;let nextLine=state$1.doc.lineAt(forward?block.to+1:block.from-1),size=nextLine.length+1;if(forward){changes.push({from:block.to,to:nextLine.to},{from:block.from,insert:nextLine.text+state$1.lineBreak});for(let r of block.ranges)ranges.push(state$jscomp$0.EditorSelection.range(Math.min(state$1.doc.length,
r.anchor+size),Math.min(state$1.doc.length,r.head+size)))}else{changes.push({from:nextLine.from,to:block.from},{from:block.to,insert:state$1.lineBreak+nextLine.text});for(let r of block.ranges)ranges.push(state$jscomp$0.EditorSelection.range(r.anchor-size,r.head-size))}}if(!changes.length)return!1;dispatch(state$1.update({changes,scrollIntoView:!0,selection:state$jscomp$0.EditorSelection.create(ranges,state$1.selection.mainIndex),userEvent:"move.line"}));return!0}function copyLine(state,dispatch,
forward){if(state.readOnly)return!1;let changes=[];for(let block of selectedLineBlocks(state))forward?changes.push({from:block.from,insert:state.doc.slice(block.from,block.to)+state.lineBreak}):changes.push({from:block.to,insert:state.lineBreak+state.doc.slice(block.from,block.to)});dispatch(state.update({changes,scrollIntoView:!0,userEvent:"input.copyline"}));return!0}function newlineAndIndent(atEof){return({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange(range=>
{let {from,to}=range;range=state$1.doc.lineAt(from);var JSCompiler_temp;if(JSCompiler_temp=!atEof&&from==to)if(JSCompiler_temp=from,/\(\)|\[\]|\{\}/.test(state$1.sliceDoc(JSCompiler_temp-1,JSCompiler_temp+1)))JSCompiler_temp={from:JSCompiler_temp,to:JSCompiler_temp};else{var context=language.syntaxTree(state$1).resolveInner(JSCompiler_temp),before=context.childBefore(JSCompiler_temp);context=context.childAfter(JSCompiler_temp);var closedBy;JSCompiler_temp=before&&context&&before.to<=JSCompiler_temp&&
context.from>=JSCompiler_temp&&(closedBy=before.type.prop(common.NodeProp.closedBy))&&-1<closedBy.indexOf(context.name)&&state$1.doc.lineAt(before.to).from==state$1.doc.lineAt(context.from).from?{from:before.to,to:context.from}:null}closedBy=JSCompiler_temp;atEof&&(from=to=(to<=range.to?range:state$1.doc.lineAt(to)).to);before=new language.IndentContext(state$1,{simulateBreak:from,simulateDoubleBreak:!!closedBy});JSCompiler_temp=language.getIndentation(before,from);null==JSCompiler_temp&&(JSCompiler_temp=
/^\s*/.exec(state$1.doc.lineAt(from).text)[0].length);for(;to<range.to&&/\s/.test(range.text[to-range.from]);)to++;closedBy?{from,to}=closedBy:from>range.from&&from<range.from+100&&!/\S/.test(range.text.slice(0,from))&&(from=range.from);JSCompiler_temp=["",language.indentString(state$1,JSCompiler_temp)];closedBy&&JSCompiler_temp.push(language.indentString(state$1,before.lineIndent(range.from,-1)));return{changes:{from,to,insert:text.Text.of(JSCompiler_temp)},range:state$jscomp$0.EditorSelection.cursor(from+
1+JSCompiler_temp[1].length)}});dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"}));return!0}}function changeBySelectedLine(state$1,f){let atLine=-1;return state$1.changeByRange(range=>{let changes=[];for(var pos=range.from;pos<=range.to;)pos=state$1.doc.lineAt(pos),pos.number>atLine&&(range.empty||range.to>pos.from)&&(f(pos,changes,range),atLine=pos.number),pos=pos.to+1;pos=state$1.changes(changes);return{changes,range:state$jscomp$0.EditorSelection.range(pos.mapPos(range.anchor,
1),pos.mapPos(range.head,1))}})}Object.defineProperty(exports,"__esModule",{value:!0});var state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),text=require("module$node_modules$$codemirror$text$dist$index_cjs"),view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs"),matchbrackets=require("module$node_modules$$codemirror$matchbrackets$dist$index_cjs"),language=require("module$node_modules$$codemirror$language$dist$index_cjs"),common=require("module$node_modules$$lezer$common$dist$index_cjs");
global=view$1=>cursorByChar(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR);require=view$1=>cursorByChar(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR);module=view$1=>cursorByGroup(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR);const cursorGroupRight=view$1=>cursorByGroup(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR),cursorSyntaxLeft=view$1=>moveSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection!=view$jscomp$0.Direction.LTR)),cursorSyntaxRight=
view$1=>moveSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection==view$jscomp$0.Direction.LTR)),cursorLineUp=view=>cursorByLine(view,!1),cursorLineDown=view=>cursorByLine(view,!0),cursorPageUp=view=>cursorByPage(view,!1),cursorPageDown=view=>cursorByPage(view,!0),cursorLineBoundaryForward=view=>moveSel(view,range=>moveByLineBoundary(view,range,!0)),cursorLineBoundaryBackward=view=>moveSel(view,range=>moveByLineBoundary(view,range,!1)),cursorLineStart=view=>moveSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).from,
1)),cursorLineEnd=view=>moveSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).to,-1)),cursorMatchingBracket=({state,dispatch})=>toMatchingBracket(state,dispatch,!1),selectCharLeft=view$1=>selectByChar(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR),selectCharRight=view$1=>selectByChar(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR),selectGroupLeft=view$1=>selectByGroup(view$1,view$1.textDirection!=view$jscomp$0.Direction.LTR),selectGroupRight=view$1=>
selectByGroup(view$1,view$1.textDirection==view$jscomp$0.Direction.LTR),selectSyntaxLeft=view$1=>extendSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection!=view$jscomp$0.Direction.LTR)),selectSyntaxRight=view$1=>extendSel(view$1,range=>moveBySyntax(view$1.state,range,view$1.textDirection==view$jscomp$0.Direction.LTR)),selectLineUp=view=>selectByLine(view,!1),selectLineDown=view=>selectByLine(view,!0),selectPageUp=view=>selectByPage(view,!1),selectPageDown=view=>selectByPage(view,
!0),selectLineBoundaryForward=view=>extendSel(view,range=>moveByLineBoundary(view,range,!0)),selectLineBoundaryBackward=view=>extendSel(view,range=>moveByLineBoundary(view,range,!1)),selectLineStart=view=>extendSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).from)),selectLineEnd=view=>extendSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).to)),cursorDocStart=({state,dispatch})=>{dispatch(setSel(state,{anchor:0}));return!0},cursorDocEnd=
({state,dispatch})=>{dispatch(setSel(state,{anchor:state.doc.length}));return!0},selectDocStart=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.selection.main.anchor,head:0}));return!0},selectDocEnd=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.selection.main.anchor,head:state.doc.length}));return!0},selectAll=({state,dispatch})=>{dispatch(state.update({selection:{anchor:0,head:state.doc.length},userEvent:"select"}));return!0},selectLine=({state:state$1,dispatch})=>{let ranges=
selectedLineBlocks(state$1).map(({from,to})=>state$jscomp$0.EditorSelection.range(from,Math.min(to+1,state$1.doc.length)));dispatch(state$1.update({selection:state$jscomp$0.EditorSelection.create(ranges),userEvent:"select"}));return!0},selectParentSyntax=({state:state$1,dispatch})=>{let selection=updateSel(state$1.selection,range=>{var _a;let context=language.syntaxTree(state$1).resolveInner(range.head,1);for(;!(context.from<range.from&&context.to>=range.to||context.to>range.to&&context.from<=range.from)&&
(null===(_a=context.parent)||void 0===_a?0:_a.parent);)context=context.parent;return state$jscomp$0.EditorSelection.range(context.to,context.from)});dispatch(setSel(state$1,selection));return!0},simplifySelection=({state:state$1,dispatch})=>{let cur=state$1.selection,selection=null;1<cur.ranges.length?selection=state$jscomp$0.EditorSelection.create([cur.main]):cur.main.empty||(selection=state$jscomp$0.EditorSelection.create([state$jscomp$0.EditorSelection.cursor(cur.main.head)]));if(!selection)return!1;
dispatch(setSel(state$1,selection));return!0},deleteByChar=(target,forward)=>deleteBy(target,pos=>{var {state}=target,line=state.doc.lineAt(pos),before;if(!forward&&pos>line.from&&pos<line.from+200&&!/[^ \t]/.test(before=line.text.slice(0,pos-line.from))){if("\t"==before[before.length-1])return pos-1;state=text.countColumn(before,state.tabSize)%language.getIndentUnit(state)||language.getIndentUnit(state);for(line=0;line<state&&" "==before[before.length-1-line];line++)pos--;before=pos}else before=
text.findClusterBreak(line.text,pos-line.from,forward,forward)+line.from,before==pos&&line.number!=(forward?state.doc.lines:1)&&(before+=forward?1:-1);return skipAtomic(target,before,forward)}),deleteCharBackward=view=>deleteByChar(view,!1),deleteCharForward=view=>deleteByChar(view,!0),deleteByGroup=(target,forward)=>deleteBy(target,start=>{let pos=start,{state}=target,line=state.doc.lineAt(pos),categorize=state.charCategorizer(pos);for(let cat=null;;){if(pos==(forward?line.to:line.from)){pos==start&&
line.number!=(forward?state.doc.lines:1)&&(pos+=forward?1:-1);break}let next=text.findClusterBreak(line.text,pos-line.from,forward)+line.from,nextChar=line.text.slice(Math.min(pos,next)-line.from,Math.max(pos,next)-line.from),nextCat=categorize(nextChar);if(null!=cat&&nextCat!=cat)break;if(" "!=nextChar||pos!=start)cat=nextCat;pos=next}return skipAtomic(target,pos,forward)}),deleteGroupBackward=target=>deleteByGroup(target,!1),deleteGroupForward=target=>deleteByGroup(target,!0),deleteToLineEnd=view=>
deleteBy(view,pos=>{let lineEnd=view.lineBlockAt(pos).to;return skipAtomic(view,pos<lineEnd?lineEnd:Math.min(view.state.doc.length,pos+1),!0)}),deleteToLineStart=view=>deleteBy(view,pos=>{let lineStart=view.lineBlockAt(pos).from;return skipAtomic(view,pos>lineStart?lineStart:Math.max(0,pos-1),!1)}),splitLine=({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange(range=>({changes:{from:range.from,to:range.to,insert:text.Text.of(["",""])},range:state$jscomp$0.EditorSelection.cursor(range.from)}));
dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"}));return!0},transposeChars=({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange(range=>{if(!range.empty||0==range.from||range.from==state$1.doc.length)return{range};range=range.from;var line=state$1.doc.lineAt(range);let from=range==line.from?range-1:text.findClusterBreak(line.text,range-line.from,!1)+line.from;line=range==line.to?range+1:text.findClusterBreak(line.text,range-line.from,!0)+
line.from;return{changes:{from,to:line,insert:state$1.doc.slice(range,line).append(state$1.doc.slice(from,range))},range:state$jscomp$0.EditorSelection.cursor(line)}});if(changes.changes.empty)return!1;dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"move.character"}));return!0},moveLineUp=({state,dispatch})=>moveLine(state,dispatch,!1),moveLineDown=({state,dispatch})=>moveLine(state,dispatch,!0),copyLineUp=({state,dispatch})=>copyLine(state,dispatch,!1),copyLineDown=({state,dispatch})=>
copyLine(state,dispatch,!0),deleteLine=view=>{if(view.state.readOnly)return!1;let {state}=view,changes=state.changes(selectedLineBlocks(state).map(({from,to})=>{0<from?from--:to<state.doc.length&&to++;return{from,to}})),selection=updateSel(state.selection,range=>view.moveVertically(range,!0)).map(changes);view.dispatch({changes,selection,scrollIntoView:!0,userEvent:"delete.line"});return!0},insertNewlineAndIndent=newlineAndIndent(!1),insertBlankLine=newlineAndIndent(!0),indentSelection=({state,dispatch})=>
{if(state.readOnly)return!1;let updated=Object.create(null),context=new language.IndentContext(state,{overrideIndentation:start=>{start=updated[start];return null==start?-1:start}}),changes$jscomp$0=changeBySelectedLine(state,(line,changes,range)=>{let indent=language.getIndentation(context,line.from);if(null!=indent){/\S/.test(line.text)||(indent=0);var cur=/^\s*/.exec(line.text)[0],norm=language.indentString(state,indent);if(cur!=norm||range.from<line.from+cur.length)updated[line.from]=indent,changes.push({from:line.from,
to:line.from+cur.length,insert:norm})}});changes$jscomp$0.changes.empty||dispatch(state.update(changes$jscomp$0,{userEvent:"indent"}));return!0},indentMore=({state,dispatch})=>{if(state.readOnly)return!1;dispatch(state.update(changeBySelectedLine(state,(line,changes)=>{changes.push({from:line.from,insert:state.facet(language.indentUnit)})}),{userEvent:"input.indent"}));return!0},indentLess=({state,dispatch})=>{if(state.readOnly)return!1;dispatch(state.update(changeBySelectedLine(state,(line,changes)=>
{let space=/^\s*/.exec(line.text)[0];if(space){var col=text.countColumn(space,state.tabSize),keep=0;for(col=language.indentString(state,Math.max(0,col-language.getIndentUnit(state)));keep<space.length&&keep<col.length&&space.charCodeAt(keep)==col.charCodeAt(keep);)keep++;changes.push({from:line.from+keep,to:line.from+space.length,insert:col.slice(keep)})}}),{userEvent:"delete.dedent"}));return!0},emacsStyleKeymap=[{key:"Ctrl-b",run:global,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:require,
shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown}],standardKeymap=
[{key:"ArrowLeft",run:global,shift:selectCharLeft,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:module,shift:selectGroupLeft},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward},{key:"ArrowRight",run:require,shift:selectCharRight,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward},{key:"ArrowUp",run:cursorLineUp,
shift:selectLineUp,preventDefault:!0},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:!0},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,
shift:selectLineBoundaryBackward},{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},
{mac:"Mod-Backspace",run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map(b=>({mac:b.key,run:b.run,shift:b.shift}))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},
{key:"Escape",run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};exports.copyLineDown=copyLineDown;exports.copyLineUp=copyLineUp;exports.cursorCharBackward=
view=>cursorByChar(view,!1);exports.cursorCharForward=view=>cursorByChar(view,!0);exports.cursorCharLeft=global;exports.cursorCharRight=require;exports.cursorDocEnd=cursorDocEnd;exports.cursorDocStart=cursorDocStart;exports.cursorGroupBackward=view=>cursorByGroup(view,!1);exports.cursorGroupForward=view=>cursorByGroup(view,!0);exports.cursorGroupLeft=module;exports.cursorGroupRight=cursorGroupRight;exports.cursorLineBoundaryBackward=cursorLineBoundaryBackward;exports.cursorLineBoundaryForward=cursorLineBoundaryForward;
exports.cursorLineDown=cursorLineDown;exports.cursorLineEnd=cursorLineEnd;exports.cursorLineStart=cursorLineStart;exports.cursorLineUp=cursorLineUp;exports.cursorMatchingBracket=cursorMatchingBracket;exports.cursorPageDown=cursorPageDown;exports.cursorPageUp=cursorPageUp;exports.cursorSubwordBackward=view=>cursorBySubword(view,!1);exports.cursorSubwordForward=view=>cursorBySubword(view,!0);exports.cursorSyntaxLeft=cursorSyntaxLeft;exports.cursorSyntaxRight=cursorSyntaxRight;exports.defaultKeymap=
defaultKeymap;exports.deleteCharBackward=deleteCharBackward;exports.deleteCharForward=deleteCharForward;exports.deleteGroupBackward=deleteGroupBackward;exports.deleteGroupForward=deleteGroupForward;exports.deleteLine=deleteLine;exports.deleteToLineEnd=deleteToLineEnd;exports.deleteToLineStart=deleteToLineStart;exports.deleteTrailingWhitespace=({state,dispatch})=>{if(state.readOnly)return!1;let changes=[];for(let pos=0,prev="",iter=state.doc.iter();;){iter.next();if(iter.lineBreak||iter.done){let trailing=
prev.search(/\s+$/);-1<trailing&&changes.push({from:pos-(prev.length-trailing),to:pos});if(iter.done)break;prev=""}else prev=iter.value;pos+=iter.value.length}if(!changes.length)return!1;dispatch(state.update({changes,userEvent:"delete"}));return!0};exports.emacsStyleKeymap=emacsStyleKeymap;exports.indentLess=indentLess;exports.indentMore=indentMore;exports.indentSelection=indentSelection;exports.indentWithTab=indentWithTab;exports.insertBlankLine=insertBlankLine;exports.insertNewline=({state,dispatch})=>
{dispatch(state.update(state.replaceSelection(state.lineBreak),{scrollIntoView:!0,userEvent:"input"}));return!0};exports.insertNewlineAndIndent=insertNewlineAndIndent;exports.insertTab=({state,dispatch})=>{if(state.selection.ranges.some(r=>!r.empty))return indentMore({state,dispatch});dispatch(state.update(state.replaceSelection("\t"),{scrollIntoView:!0,userEvent:"input"}));return!0};exports.moveLineDown=moveLineDown;exports.moveLineUp=moveLineUp;exports.selectAll=selectAll;exports.selectCharBackward=
view=>selectByChar(view,!1);exports.selectCharForward=view=>selectByChar(view,!0);exports.selectCharLeft=selectCharLeft;exports.selectCharRight=selectCharRight;exports.selectDocEnd=selectDocEnd;exports.selectDocStart=selectDocStart;exports.selectGroupBackward=view=>selectByGroup(view,!1);exports.selectGroupForward=view=>selectByGroup(view,!0);exports.selectGroupLeft=selectGroupLeft;exports.selectGroupRight=selectGroupRight;exports.selectLine=selectLine;exports.selectLineBoundaryBackward=selectLineBoundaryBackward;
exports.selectLineBoundaryForward=selectLineBoundaryForward;exports.selectLineDown=selectLineDown;exports.selectLineEnd=selectLineEnd;exports.selectLineStart=selectLineStart;exports.selectLineUp=selectLineUp;exports.selectMatchingBracket=({state,dispatch})=>toMatchingBracket(state,dispatch,!0);exports.selectPageDown=selectPageDown;exports.selectPageUp=selectPageUp;exports.selectParentSyntax=selectParentSyntax;exports.selectSubwordBackward=view=>selectBySubword(view,!1);exports.selectSubwordForward=
view=>selectBySubword(view,!0);exports.selectSyntaxLeft=selectSyntaxLeft;exports.selectSyntaxRight=selectSyntaxRight;exports.simplifySelection=simplifySelection;exports.splitLine=splitLine;exports.standardKeymap=standardKeymap;exports.transposeChars=transposeChars}
//# sourceMappingURL=module$node_modules$$codemirror$commands$dist$index_cjs.js.map
