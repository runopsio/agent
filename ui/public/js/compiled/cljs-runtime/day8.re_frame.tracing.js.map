{"version":3,"sources":["day8/re_frame/tracing.cljc"],"mappings":";AAaS,AAACA;AAED;;;6CAAA,AAAAC,YAAA,6CAAA,tGAAaC;AAGtB;;;gDAAA,hDAAeC;AAAf,AAOED;;AAEF,AAAKE,iDAAoBC;AACzB,AAAKC,mDAAsBC;AAgB3B,qCAAA,rCAAMC,kFAAcC;AAApB,AAAA;AAEE,IAAOC,MAAI,AAACC,+CAAkBF;WAA9B,PACOG;;AADP,AAEE,IAAMC,OAAK,AAACC,iBAAOJ;AAAnB,AACE,GACE,AAACK,uBAAOL;AAAKE;;AADf,GAEE,iBAAAI,hBAASH;AAAM,eAAO,AAACI,iBAAOP;eAAK,AAACQ,6CAAKN,KAAKC;;;;;AAFhD,AAGQ,eAAO,AAACI,iBAAOP;eAAKE;;;;;;;;;;AAGlC,AAAA,gCAAA,wCAAAO,xEAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,mEAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,qEAAA,rEAAME,gFAASM,eAAYC;AAA3B,AACE,IAAMvB,OAAgB,iBAAAwB,mBAAI,AAAA,mFAAA,AAAA,mFAAIF;AAAR,AAAA,oBAAAE;AAAAA;;AAAA;;;IAChBC,kJAAoBH,hIAAgB,4CAAA,AAAA,oGAAA,hJAACI;IACrCC,OAAgB,gJAAA,hJAACD,4CAAI,AAAA,oFAAOJ;IAC5BM,eAAgB,AAAC7B,mCAAaC;AAHpC,AAIE,GAAI,6CAAA,7CAACiC,mGAAQR;AAAb,OAAAI,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,UAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,6EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,eAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,kBAAA,KAAA,IAAA,eAAA,KAAA,IAAA,nfACKhC,kTAEiB2B,gGAAMJ,mDAAWK;;AAHvC,OAAAC,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,UAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,oGAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,AAAAH,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,6EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,+FAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,eAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,kBAAA,KAAA,IAAA,eAAA,KAAA,IAAA,lwBAKKhC,8CACA,AAAA,yFAAU2B,qWACO,AAAA,oFAAOA,iGAAOJ,mDAAWK;;;;AAZnD,CAAA,wDAAA,xDAAMZ;;AAAN;AAAA,CAAA,kDAAA,WAAAC,7DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,SAAAD;;;AAAA","names":["cljs.core/enable-console-print!","js/goog.define","day8.re-frame.tracing/trace-enabled?","day8.re-frame.tracing/is-trace-enabled?","day8.re-frame.tracing/reset-indent-level!","day8.re-frame.debux.common.util/reset-indent-level!","day8.re-frame.tracing/set-print-seq-length!","day8.re-frame.debux.common.util/set-print-seq-length!","day8.re-frame.tracing/find-symbols","args","loc","day8.re-frame.debux.common.util/sequential-zip","seen","node","clojure.zip/node","clojure.zip/end?","cljs.core/Symbol","clojure.zip/next","cljs.core.conj","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","day8.re-frame.tracing/fn-body","seq75739","G__75741","cljs.core/first","cljs.core/next","self__4851__auto__","args+body","send-form","or__4253__auto__","body-or-prepost","cljs.core.nth","body","args-symbols","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core._EQ_"],"sourcesContent":["(ns day8.re-frame.tracing\n  #?(:cljs (:require-macros\n             [day8.re-frame.debux.dbgn :as dbgn]\n             [day8.re-frame.debux.cs.macro-types :as mt]\n             [day8.re-frame.tracing])\n     :clj (:require\n            [day8.re-frame.debux.dbgn :as dbgn]\n            [day8.re-frame.debux.cs.macro-types :as mt]))\n  (:require [day8.re-frame.debux.common.util :as ut]\n            [day8.re-frame.debux.common.macro-specs :as ms]\n            [clojure.spec.alpha :as s]\n            [clojure.zip :as z]))\n\n#?(:cljs (enable-console-print!))\n\n#?(:cljs (goog-define trace-enabled? false)\n   :clj  (def ^boolean trace-enabled? false))\n\n(defn ^boolean is-trace-enabled?\n  \"See https://groups.google.com/d/msg/clojurescript/jk43kmYiMhA/IHglVr_TPdgJ for more details\"\n  ;; We can remove this extra step of type hinting indirection once our minimum CLJS version includes\n  ;; https://dev.clojure.org/jira/browse/CLJS-1439\n  ;; r1.10.63 is the first version with this:\n  ;; https://github.com/clojure/clojurescript/commit/9ec796d791b1b2bd613af2f62cdecfd25caa6482\n  []\n  trace-enabled?)\n\n(def reset-indent-level! ut/reset-indent-level!)\n(def set-print-seq-length! ut/set-print-seq-length!)\n\n\n;;; debugging APIs\n(defmacro dbgn [form & opts]\n  (let [opts' (ut/parse-opts opts)]\n    `(day8.re-frame.debux.dbgn/dbgn ~form ~opts')))\n\n;;; macro registering APIs\n(defmacro register-macros! [macro-type symbols]\n  `(day8.re-frame.debux.cs.macro-types/register-macros! ~macro-type ~symbols))\n\n(defmacro show-macros\n  ([] `(day8.re-frame.debux.cs.macro-types/show-macros))\n  ([macro-type] `(day8.re-frame.debux.cs.macro-types/show-macros ~macro-type)))\n\n(defn find-symbols [args]\n  \"iterate through the function args and get a list of the symbols\"\n  (loop [loc (ut/sequential-zip args)\n         seen []]\n    (let [node (z/node loc)]\n      (cond\n        (z/end? loc) seen\n        (symbol? node) (recur (z/next loc) (conj seen node))\n        :else (recur (z/next loc) seen)\n        ))))\n\n(defn fn-body [args+body & send-form]\n  (let [args            (or (-> args+body :args :args) [])\n        body-or-prepost (-> args+body :body (nth 0))\n        body            (nth (:body args+body) 1)\n        args-symbols    (find-symbols args)]\n    (if (= :body body-or-prepost)   ;; no pre and post conditions\n      `(~args\n      ;;  ~@(map (fn [body] `(dbgn ~body)) (nth (:body args+body) 1)))\n        (dbgn/dbgn-forms ~body ~send-form ~args-symbols))\n    ;; prepost+body\n      `(~args\n        ~(:prepost body)\n        (dbgn/dbgn-forms ~(:body body) ~send-form ~args-symbols)))))\n\n;; Components of a defn\n;; name\n;; docstring?\n;; meta?\n;; bs (1-n)\n;; body\n;; prepost?\n\n(defmacro defn-traced*\n  [& definition]\n  (let [conformed (s/conform ::ms/defn-args definition)\n        name      (:name conformed)\n        bs        (:bs conformed)\n        arity-1?  (= (nth bs 0) :arity-1)\n        args+body (nth bs 1)]\n    (if arity-1?\n      `(defn ~name ~@(fn-body args+body &form))\n      `(defn ~name ~@(map #(fn-body % &form) (:bodies args+body))))))\n\n(defmacro defn-traced\n  \"Traced defn\"\n  {:arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])}\n  [& definition]\n  `(if (is-trace-enabled?)\n     (defn-traced* ~@definition)\n     (defn ~@definition)))\n\n\n\n;; Components of a fn\n;; name?\n;; bs (1-n)\n;; body\n;; prepost?\n\n(defmacro fn-traced*\n  \"Traced form of fn. Prefer fn-traced to compile out under advanced optimizations.\"\n  [& definition]\n  (let [conformed (s/conform ::ms/fn-args definition)\n        name      (:name conformed)\n        bs        (:bs conformed)\n        arity-1?  (= (nth bs 0) :arity-1)\n        args+body (nth bs 1)]\n    (if arity-1?\n      ;; If name is nil, then the empty vector is removed by the unquote\n      `(fn ~@(when name [name])\n         ~@(fn-body args+body &form))\n      ;; arity-n\n      (let [bodies (:bodies args+body)]\n        `(fn ~@(when name [name])\n           ~@(map #(fn-body % &form) bodies))))))\n\n(defmacro fn-traced\n  \"Defines a traced fn\"\n  {:arglists '[(fn name? [params*] exprs*) (fn name? ([params*] exprs*) +)]}\n  [& definition]\n  `(if (is-trace-enabled?)\n     (fn-traced* ~@definition)\n     (fn ~@definition)))\n\n"]}