shadow$provide.module$node_modules$$codemirror$history$dist$index_cjs=function(global,require,module,exports){function changeEnd(changes){let end=0;changes.iterChangedRanges((_,to)=>end=to);return end}function cmd(side,selection){return function({state,dispatch}){if(!selection&&state.readOnly)return!1;let historyState=state.field(historyField_,!1);if(!historyState)return!1;state=historyState.pop(side,state,selection);if(!state)return!1;dispatch(state);return!0}}function depth(side){return function(state){state=
state.field(historyField_,!1);if(!state)return 0;state=0==side?state.done:state.undone;return state.length-(state.length&&!state[0].changes?1:0)}}function updateBranch(branch,to,maxLen,newEvent){branch=branch.slice(to+1>maxLen+20?to-maxLen-1:0,to);branch.push(newEvent);return branch}function isAdjacent(a,b){let ranges=[],isAdjacent=!1;a.iterChangedRanges((f,t)=>ranges.push(f,t));b.iterChangedRanges((_f,_t,f,t)=>{for(_f=0;_f<ranges.length;){_t=ranges[_f++];let to=ranges[_f++];t>=_t&&f<=to&&(isAdjacent=
!0)}});return isAdjacent}function eqSelectionShape(a,b){return a.ranges.length==b.ranges.length&&0===a.ranges.filter((r,i)=>r.empty!=b.ranges[i].empty).length}function conc(a,b){return a.length?b.length?a.concat(b):a:b}function addSelection(branch,selection){if(branch.length){let lastEvent=branch[branch.length-1],sels=lastEvent.selectionsAfter.slice(Math.max(0,lastEvent.selectionsAfter.length-200));if(sels.length&&sels[sels.length-1].eq(selection))return branch;sels.push(selection);return updateBranch(branch,
branch.length-1,1E9,lastEvent.setSelAfter(sels))}return[HistEvent.selection([selection])]}function addMappingToBranch(branch,mapping){if(!branch.length)return branch;let length=branch.length;for(var selections=none;length;){selections=mapEvent(branch[length-1],mapping,selections);if(selections.changes&&!selections.changes.empty||selections.effects.length)return branch=branch.slice(0,length),branch[length-1]=selections,branch;mapping=selections.mapped;length--;selections=selections.selectionsAfter}return selections.length?
[HistEvent.selection(selections)]:none}function mapEvent(event,mapping,extraSelections){extraSelections=conc(event.selectionsAfter.length?event.selectionsAfter.map(s=>s.map(mapping)):none,extraSelections);if(!event.changes)return HistEvent.selection(extraSelections);let mappedChanges=event.changes.map(mapping),before=mapping.mapDesc(event.changes,!0),fullMapping=event.mapped?event.mapped.composeDesc(before):before;return new HistEvent(mappedChanges,state$jscomp$0.StateEffect.mapEffects(event.effects,
mapping),fullMapping,event.startSelection.map(before),extraSelections)}Object.defineProperty(exports,"__esModule",{value:!0});var state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs");const fromHistory=state$jscomp$0.Annotation.define(),isolateHistory=state$jscomp$0.Annotation.define(),invertedEffects=state$jscomp$0.Facet.define(),historyConfig=state$jscomp$0.Facet.define({combine(configs){return state$jscomp$0.combineConfig(configs,
{minDepth:100,newGroupDelay:500},{minDepth:Math.max,newGroupDelay:Math.min})}}),historyField_=state$jscomp$0.StateField.define({create(){return HistoryState.empty},update(state$1,tr){let config=tr.state.facet(historyConfig);var fromHist=tr.annotation(fromHistory);if(fromHist){var selection=tr.docChanged?state$jscomp$0.EditorSelection.single(changeEnd(tr.changes)):void 0;selection=HistEvent.fromTransaction(tr,selection);var from=fromHist.side;state$1=0==from?state$1.undone:state$1.done;state$1=selection?
updateBranch(state$1,state$1.length,config.minDepth,selection):addSelection(state$1,tr.startState.selection);return new HistoryState(0==from?fromHist.rest:state$1,0==from?state$1:fromHist.rest)}fromHist=tr.annotation(isolateHistory);if("full"==fromHist||"before"==fromHist)state$1=state$1.isolate();if(!1===tr.annotation(state$jscomp$0.Transaction.addToHistory))return tr.changes.empty?state$1:state$1.addMapping(tr.changes.desc);selection=HistEvent.fromTransaction(tr);from=tr.annotation(state$jscomp$0.Transaction.time);
let userEvent=tr.annotation(state$jscomp$0.Transaction.userEvent);selection?state$1=state$1.addChanges(selection,from,userEvent,config.newGroupDelay,config.minDepth):tr.selection&&(state$1=state$1.addSelection(tr.startState.selection,from,userEvent,config.newGroupDelay));if("full"==fromHist||"after"==fromHist)state$1=state$1.isolate();return state$1},toJSON(value){return{done:value.done.map(e=>e.toJSON()),undone:value.undone.map(e=>e.toJSON())}},fromJSON(json){return new HistoryState(json.done.map(HistEvent.fromJSON),
json.undone.map(HistEvent.fromJSON))}});global=historyField_;const undo=cmd(0,!1),redo=cmd(1,!1);require=cmd(0,!0);module=cmd(1,!0);const undoDepth=depth(0),redoDepth=depth(1);class HistEvent{constructor(changes,effects,mapped,startSelection,selectionsAfter){this.changes=changes;this.effects=effects;this.mapped=mapped;this.startSelection=startSelection;this.selectionsAfter=selectionsAfter}setSelAfter(after){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,after)}toJSON(){var _a,
_b,_c;return{changes:null===(_a=this.changes)||void 0===_a?void 0:_a.toJSON(),mapped:null===(_b=this.mapped)||void 0===_b?void 0:_b.toJSON(),startSelection:null===(_c=this.startSelection)||void 0===_c?void 0:_c.toJSON(),selectionsAfter:this.selectionsAfter.map(s=>s.toJSON())}}static fromJSON(json){return new HistEvent(json.changes&&state$jscomp$0.ChangeSet.fromJSON(json.changes),[],json.mapped&&state$jscomp$0.ChangeDesc.fromJSON(json.mapped),json.startSelection&&state$jscomp$0.EditorSelection.fromJSON(json.startSelection),
json.selectionsAfter.map(state$jscomp$0.EditorSelection.fromJSON))}static fromTransaction(tr,selection){let effects=none;for(let invert of tr.startState.facet(invertedEffects)){let result=invert(tr);result.length&&(effects=effects.concat(result))}return!effects.length&&tr.changes.empty?null:new HistEvent(tr.changes.invert(tr.startState.doc),effects,void 0,selection||tr.startState.selection,none)}static selection(selections){return new HistEvent(void 0,none,void 0,void 0,selections)}}const none=[],
joinableUserEvent=/^(input\.type|delete)($|\.)/;class HistoryState{constructor(done,undone,prevTime=0,prevUserEvent){this.done=done;this.undone=undone;this.prevTime=prevTime;this.prevUserEvent=prevUserEvent}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(event,time,userEvent,newGroupDelay,maxLen){let done=this.done,lastEvent=done[done.length-1];done=lastEvent&&lastEvent.changes&&!lastEvent.changes.empty&&event.changes&&(!userEvent||joinableUserEvent.test(userEvent))&&
(!lastEvent.selectionsAfter.length&&time-this.prevTime<newGroupDelay&&isAdjacent(lastEvent.changes,event.changes)||"input.type.compose"==userEvent)?updateBranch(done,done.length-1,maxLen,new HistEvent(event.changes.compose(lastEvent.changes),conc(event.effects,lastEvent.effects),lastEvent.mapped,lastEvent.startSelection,none)):updateBranch(done,done.length,maxLen,event);return new HistoryState(done,none,time,userEvent)}addSelection(selection,time,userEvent,newGroupDelay){let last=this.done.length?
this.done[this.done.length-1].selectionsAfter:none;return 0<last.length&&time-this.prevTime<newGroupDelay&&userEvent==this.prevUserEvent&&userEvent&&/^select($|\.)/.test(userEvent)&&eqSelectionShape(last[last.length-1],selection)?this:new HistoryState(addSelection(this.done,selection),this.undone,time,userEvent)}addMapping(mapping){return new HistoryState(addMappingToBranch(this.done,mapping),addMappingToBranch(this.undone,mapping),this.prevTime,this.prevUserEvent)}pop(side,state,selection){var branch=
0==side?this.done:this.undone;if(0==branch.length)return null;var event=branch[branch.length-1];if(selection&&event.selectionsAfter.length){selection=state.update;event=event.selectionsAfter[event.selectionsAfter.length-1];var JSCompiler_temp_const=fromHistory.of;let last=branch[branch.length-1],newBranch=branch.slice();newBranch[branch.length-1]=last.setSelAfter(last.selectionsAfter.slice(0,last.selectionsAfter.length-1));return selection.call(state,{selection:event,annotations:JSCompiler_temp_const.call(fromHistory,
{side,rest:newBranch}),userEvent:0==side?"select.undo":"select.redo",scrollIntoView:!0})}return event.changes?(branch=1==branch.length?none:branch.slice(0,branch.length-1),event.mapped&&(branch=addMappingToBranch(branch,event.mapped)),state.update({changes:event.changes,selection:event.startSelection,effects:event.effects,annotations:fromHistory.of({side,rest:branch}),filter:!1,userEvent:0==side?"undo":"redo",scrollIntoView:!0})):null}}HistoryState.empty=new HistoryState(none,none);const historyKeymap=
[{key:"Mod-z",run:undo,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:!0},{key:"Mod-u",run:require,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:module,preventDefault:!0}];exports.history=function(config={}){return[historyField_,historyConfig.of(config),view$jscomp$0.EditorView.domEventHandlers({beforeinput(e,view){let command="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;if(!command)return!1;e.preventDefault();return command(view)}})]};exports.historyField=
global;exports.historyKeymap=historyKeymap;exports.invertedEffects=invertedEffects;exports.isolateHistory=isolateHistory;exports.redo=redo;exports.redoDepth=redoDepth;exports.redoSelection=module;exports.undo=undo;exports.undoDepth=undoDepth;exports.undoSelection=require}
//# sourceMappingURL=module$node_modules$$codemirror$history$dist$index_cjs.js.map
