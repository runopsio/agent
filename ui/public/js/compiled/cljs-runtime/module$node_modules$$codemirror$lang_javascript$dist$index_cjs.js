shadow$provide.module$node_modules$$codemirror$lang_javascript$dist$index_cjs=function(global,require,module,exports){function mapPos(line,col,doc,offset){return doc.line(line+offset.line).from+col+(1==line?offset.col-1:-1)}function translateDiagnostic(input,doc,offset){let start$jscomp$0=mapPos(input.line,input.column,doc,offset);doc={from:start$jscomp$0,to:null!=input.endLine&&1!=input.endColumn?mapPos(input.endLine,input.endColumn,doc,offset):start$jscomp$0,message:input.message,source:input.ruleId?
"jshint:"+input.ruleId:"jshint",severity:1==input.severity?"warning":"error"};if(input.fix){let {range,text}=input.fix,from=range[0]+offset.pos-start$jscomp$0,to=range[1]+offset.pos-start$jscomp$0;doc.actions=[{name:"fix",apply(view,start){view.dispatch({changes:{from:start+from,to:start+to,insert:text},scrollIntoView:!0})}}]}return doc}Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$lezer$javascript$dist$index_cjs");var language=require("module$node_modules$$codemirror$language$dist$index_cjs");
module=require("module$node_modules$$codemirror$highlight$dist$index_cjs");var autocomplete=require("module$node_modules$$codemirror$autocomplete$dist$index_cjs");const snippets=[autocomplete.snippetCompletion("function ${name}(${params}) {\n\t${}\n}",{label:"function",detail:"definition",type:"keyword"}),autocomplete.snippetCompletion("for (let ${index} \x3d 0; ${index} \x3c ${bound}; ${index}++) {\n\t${}\n}",{label:"for",detail:"loop",type:"keyword"}),autocomplete.snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}",
{label:"for",detail:"of loop",type:"keyword"}),autocomplete.snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}",{label:"try",detail:"block",type:"keyword"}),autocomplete.snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}",{label:"class",detail:"definition",type:"keyword"}),autocomplete.snippetCompletion('import {${names}} from "${module}"\n${}',{label:"import",detail:"named",type:"keyword"}),autocomplete.snippetCompletion('import ${name} from "${module}"\n${}',
{label:"import",detail:"default",type:"keyword"})],javascriptLanguage=language.LRLanguage.define({parser:global.parser.configure({props:[language.indentNodeProp.add({IfStatement:language.continuedIndent({except:/^\s*({|else\b)/}),TryStatement:language.continuedIndent({except:/^\s*({|catch\b|finally\b)/}),LabeledStatement:language.flatIndent,SwitchBody:context=>{var after=context.textAfter;let closed=/^\s*\}/.test(after);after=/^\s*(case|default)\b/.test(after);return context.baseIndent+(closed?0:
after?1:2)*context.unit},Block:language.delimitedIndent({closing:"}"}),ArrowFunction:cx=>cx.baseIndent+cx.unit,"TemplateString BlockComment":()=>-1,"Statement Property":language.continuedIndent({except:/^{/}),JSXElement(context){let closed=/^\s*<\//.test(context.textAfter);return context.lineIndent(context.node.from)+(closed?0:context.unit)},JSXEscape(context){let closed=/\s*\}/.test(context.textAfter);return context.lineIndent(context.node.from)+(closed?0:context.unit)},["JSXOpenTag JSXSelfClosingTag"](context){return context.column(context.node.from)+
context.unit}}),language.foldNodeProp.add({"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression":language.foldInside,BlockComment(tree){return{from:tree.from+2,to:tree.to-2}}}),module.styleTags({"get set async static":module.tags.modifier,"for while do if else switch try catch finally return throw break continue default case":module.tags.controlKeyword,"in of await yield void typeof delete instanceof":module.tags.operatorKeyword,"let var const function class extends":module.tags.definitionKeyword,
"import export from":module.tags.moduleKeyword,"with debugger as new":module.tags.keyword,TemplateString:module.tags.special(module.tags.string),Super:module.tags.atom,BooleanLiteral:module.tags.bool,this:module.tags.self,null:module.tags.null,Star:module.tags.modifier,VariableName:module.tags.variableName,"CallExpression/VariableName TaggedTemplateExpression/VariableName":module.tags.function(module.tags.variableName),VariableDefinition:module.tags.definition(module.tags.variableName),Label:module.tags.labelName,
PropertyName:module.tags.propertyName,PrivatePropertyName:module.tags.special(module.tags.propertyName),"CallExpression/MemberExpression/PropertyName":module.tags.function(module.tags.propertyName),"FunctionDeclaration/VariableDefinition":module.tags.function(module.tags.definition(module.tags.variableName)),"ClassDeclaration/VariableDefinition":module.tags.definition(module.tags.className),PropertyDefinition:module.tags.definition(module.tags.propertyName),PrivatePropertyDefinition:module.tags.definition(module.tags.special(module.tags.propertyName)),
UpdateOp:module.tags.updateOperator,LineComment:module.tags.lineComment,BlockComment:module.tags.blockComment,Number:module.tags.number,String:module.tags.string,ArithOp:module.tags.arithmeticOperator,LogicOp:module.tags.logicOperator,BitOp:module.tags.bitwiseOperator,CompareOp:module.tags.compareOperator,RegExp:module.tags.regexp,Equals:module.tags.definitionOperator,"Arrow : Spread":module.tags.punctuation,"( )":module.tags.paren,"[ ]":module.tags.squareBracket,"{ }":module.tags.brace,"InterpolationStart InterpolationEnd":module.tags.special(module.tags.brace),
".":module.tags.derefOperator,", ;":module.tags.separator,TypeName:module.tags.typeName,TypeDefinition:module.tags.definition(module.tags.typeName),"type enum interface implements namespace module declare":module.tags.definitionKeyword,"abstract global Privacy readonly override":module.tags.modifier,"is keyof unique infer":module.tags.operatorKeyword,JSXAttributeValue:module.tags.attributeValue,JSXText:module.tags.content,"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag":module.tags.angleBracket,
"JSXIdentifier JSXNameSpacedName":module.tags.tagName,"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName":module.tags.attributeName})]}),languageData:{closeBrackets:{brackets:"([{'\"`".split("")},commentTokens:{line:"//",block:{open:"/*",close:"*/"}},indentOnInput:/^\s*(?:case |default:|\{|\}|<\/)$/,wordChars:"$"}}),typescriptLanguage=javascriptLanguage.configure({dialect:"ts"}),jsxLanguage=javascriptLanguage.configure({dialect:"jsx"}),tsxLanguage=javascriptLanguage.configure({dialect:"jsx ts"});
exports.esLint=function(eslint,config){config||(config={parserOptions:{ecmaVersion:2019,sourceType:"module"},env:{browser:!0,node:!0,es6:!0,es2015:!0,es2017:!0,es2020:!0},rules:{}},eslint.getRules().forEach((desc,name)=>{desc.meta.docs.recommended&&(config.rules[name]=2)}));return view=>{({state:view}=view);let found=[];for(let {from,to}of javascriptLanguage.findRegions(view)){var fromLine=view.doc.lineAt(from);fromLine={line:fromLine.number-1,col:from-fromLine.from,pos:from};for(let d of eslint.verify(view.sliceDoc(from,
to),config))found.push(translateDiagnostic(d,view.doc,fromLine))}return found}};exports.javascript=function(config={}){return new language.LanguageSupport(config.jsx?config.typescript?tsxLanguage:jsxLanguage:config.typescript?typescriptLanguage:javascriptLanguage,javascriptLanguage.data.of({autocomplete:autocomplete.ifNotIn(["LineComment","BlockComment","String"],autocomplete.completeFromList(snippets))}))};exports.javascriptLanguage=javascriptLanguage;exports.jsxLanguage=jsxLanguage;exports.snippets=
snippets;exports.tsxLanguage=tsxLanguage;exports.typescriptLanguage=typescriptLanguage}
//# sourceMappingURL=module$node_modules$$codemirror$lang_javascript$dist$index_cjs.js.map
