{
"version":3,
"file":"module$node_modules$$codemirror$matchbrackets$dist$index_cjs.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/@codemirror/matchbrackets/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$codemirror$matchbrackets$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar state = require('@codemirror/state');\nvar language = require('@codemirror/language');\nvar view = require('@codemirror/view');\nvar common = require('@lezer/common');\n\nconst baseTheme = view.EditorView.baseTheme({\n    \".cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\n    \".cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = state.Facet.define({\n    combine(configs) {\n        return state.combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = view.Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = view.Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nconst bracketMatchingState = state.StateField.define({\n    create() { return view.Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return view.Decoration.set(decorations, true);\n    },\n    provide: f => view.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? common.NodeProp.openedBy : common.NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = language.syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for (let cur = node; cur; cur = cur.parent) {\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to)\n            return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return {\n                            start: firstToken,\n                            end: cursor.from == cursor.to ? undefined : { from: cursor.from, to: cursor.to },\n                            matched: false\n                        };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexports.bracketMatching = bracketMatching;\nexports.matchBrackets = matchBrackets;\n\n};"],
"names":["shadow$provide","global","require","module","exports","matchingNodes","node","dir","brackets","byProp","prop","common","NodeProp","openedBy","closedBy","name","length","index","indexOf","matchBrackets","state","pos","config","maxScanDistance","DefaultScanDist","DefaultBrackets","tree","language","syntaxTree","resolveInner","cur","parent","matches","type","from","to","token","firstToken","depth","cursor","childBefore","childAfter","matching","start","end","matched","undefined","prevSibling","nextSibling","startCh","sliceDoc","bracket","startToken","iter","doc","iterRange","distance","next","done","text","value","basePos","found","resolve","tokenType","Object","defineProperty","view","baseTheme","EditorView","backgroundColor","bracketMatchingConfig","Facet","define","combine","configs","combineConfig","afterCursor","matchingMark","Decoration","mark","class","nonmatchingMark","bracketMatchingUnique","StateField","bracketMatchingState","create","none","update","deco","tr","docChanged","selection","decorations","facet","range","ranges","empty","match","head","push","set","provide","f","bracketMatching","of"]
}
